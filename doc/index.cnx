*index.txt*     For Vim version 7.4.  最近更新: 2013年8月


		  VIM 参考手册    by Bram Moolenaar
				译者: Willis
				http://vimcdoc.sf.net

								*index*
本文件包含各个模式下的所有命令的一个列表。包含它们的标签和简单说明。列表以
ASCII 值排序。

提示: 要找特定功能，使用搜索命令。例如，要找寻如何删除，使用: "/删除"。

1. 插入模式				|insert-index|
2. 普通模式				|normal-index|
   2.1. 文本对象			|objects|
   2.2. 窗口命令			|CTRL-W|
   2.3. 方括号命令			|[|
   2.4. 'g' 开头的命令			|g|
   2.5. 'z' 开头的命令			|z|
3. 可视模式				|visual-index|
4. 命令行编辑				|ex-edit-index|
5. EX 命令				|ex-cmd-index|

选项总览可见 help.txt |option-list|。
内建函数总览可见 |functions|。
Vim 变量的列表可见 |vim-variable|。
帮助项目的完整列表可见 |help-tags|。

==============================================================================
1. 插入模式						*insert-index*

标签		字符		插入模式动作~
-----------------------------------------------------------------------
|i_CTRL-@|	CTRL-@		插入最近插入的文本并停止插入
|i_CTRL-A|	CTRL-A		插入最近插入的文本
		CTRL-B		不用 |i_CTRL-B-gone|
|i_CTRL-C|	CTRL-C		退出插入模式，不检查缩写，除非置位了
				'insertmode'。
|i_CTRL-D|	CTRL-D		在当前行删除一个 shiftwidth 的缩进
|i_CTRL-E|	CTRL-E		插入光标下方的字符
		CTRL-F		不用 (但缺省是 'cinkeys' 中的一项，用以重新缩
				进本行)
|i_CTRL-G_j|	CTRL-G CTRL-J	往下一行，到插入开始的列
|i_CTRL-G_j|	CTRL-G j	往下一行，到插入开始的列
|i_CTRL-G_j|	CTRL-G <Down>	往下一行，到插入开始的列
|i_CTRL-G_k|	CTRL-G CTRL-K	往上一行，到插入开始的列
|i_CTRL-G_k|	CTRL-G k	往上一行，到插入开始的列
|i_CTRL-G_k|	CTRL-G <Up>	往上一行，到插入开始的列
|i_CTRL-G_u|	CTRL-G u	开始新的不可撤消的编辑
|i_<BS>|	<BS>		删除光标前的字符
|i_digraph|	{char1}<BS>{char2}
				输入二合字母 (只有打开了 'digraph' 选项才有效)
|i_CTRL-H|	CTRL-H		等同于 <BS>
|i_<Tab>|	<Tab>		插入 <Tab> 字符
|i_CTRL-I|	CTRL-I		等同于 <Tab>
|i_<NL>|	<NL>		等同于 <CR>
|i_CTRL-J|	CTRL-J		等同于 <CR>
|i_CTRL-K|	CTRL-K {char1} {char2}
				输入二合字母
|i_CTRL-L|	CTRL-L		'insertmode' 打开时: 离开插入模式
|i_<CR>|	<CR>		开始新行
|i_CTRL-M|	CTRL-M		等同于 <CR>
|i_CTRL-N|	CTRL-N		查找光标前面的关键字的下一个匹配
|i_CTRL-O|	CTRL-O		执行单个命令然后回到插入模式
|i_CTRL-P|	CTRL-P		查找光标前面的关键字的前一个匹配
|i_CTRL-Q|	CTRL-Q		等同于 CTRL-V，除非它用于终端控制流
|i_CTRL-R|	CTRL-R {0-9a-z"%#*:=}
				插入寄存器内容
|i_CTRL-R_CTRL-R| CTRL-R CTRL-R {0-9a-z"%#*:=}
				按本义插入寄存器内容
|i_CTRL-R_CTRL-O| CTRL-R CTRL-O {0-9a-z"%#*:=}
				按本义插入寄存器内容，而且不自动缩进
|i_CTRL-R_CTRL-P| CTRL-R CTRL-P {0-9a-z"%#*:=}
				按本义插入寄存器内容，而且修正缩进
		CTRL-S		(用于终端控制流)
|i_CTRL-T|	CTRL-T		在当前行插入一个 shiftwidth 的缩进
|i_CTRL-U|	CTRL-U		删除当前行的所有输入字符
|i_CTRL-V|	CTRL-V {char}	按本义插入下一个非数字字符
|i_CTRL-V_digit| CTRL-V {number} 插入三位十进制数字代表的单个字节。
|i_CTRL-W|	CTRL-W		删除光标前的单词
|i_CTRL-X|	CTRL-X {mode}	进入 CTRL-X 子模式，见 |i_CTRL-X_index|
|i_CTRL-Y|	CTRL-Y		插入光标上方的字符
|i_CTRL-Z|	CTRL-Z		'insertmode' 打开时: 暂停 Vim
|i_<Esc>|	<Esc>		结束插入模式 (除非打开了 'insertmode')
|i_CTRL-[|	CTRL-[		等同于 <Esc>
|i_CTRL-\_CTRL-N| CTRL-\ CTRL-N	进入普通模式
|i_CTRL-\_CTRL-G| CTRL-\ CTRL-G	进入 'insertmode' 指定的模式
		CTRL-\ a - z	保留给扩展用
		CTRL-\ others	不用
|i_CTRL-]|	CTRL-]		切换缩写
|i_CTRL-^|	CTRL-^		切换 |:lmap| 映射的使用
|i_CTRL-_|	CTRL-_		'allowrevins' 打开时: 改变语言
				(希伯来语，波斯语等) {仅当编译时加入
				|+rightleft| 特性才有效}

		<Space> to '~'	不用，除了 CTRL-D 之前的 '0' 和 '^'

|i_0_CTRL-D|	0 CTRL-D	删除当前行的所有缩进
|i_^_CTRL-D|	^ CTRL-D	删除当前行的所有缩进，在下一行恢复删除的缩进

|i_<Del>|	<Del>		删除光标所在的字符

		Meta 字符 (0x80 到 0xff，128 到 255)
				不用

|i_<Left>|	<Left>		光标左移一个字符
|i_<S-Left>|	<S-Left>	光标左移一个单词
|i_<C-Left>|	<C-Left>	光标左移一个单词
|i_<Right>|	<Right>		光标右移一个字符
|i_<S-Right>|	<S-Right>	光标右移一个单词
|i_<C-Right>|	<C-Right>	光标右移一个单词
|i_<Up>|	<Up>		光标上移一行
|i_<S-Up>|	<S-Up>		等同于 <PageUp>
|i_<Down>|	<Down>		光标下移一行
|i_<S-Down>|	<S-Down>	等同于 <PageDown>
|i_<Home>|	<Home>		光标移到行首
|i_<C-Home>|	<C-Home>	光标移到文件首
|i_<End>|	<End>		光标移到行尾后面
|i_<C-End>|	<C-End>		光标移到文件尾后面
|i_<PageUp>|	<PageUp>	满屏上滚
|i_<PageDown>|	<PageDown>	满屏下滚
|i_<F1>|	<F1>		等同于 <Help>
|i_<Help>|	<Help>		停止插入模式显示帮助窗口
|i_<Insert>|	<Insert>	切换插入/替换模式
|i_<LeftMouse>|	<LeftMouse>	光标移到鼠标点击处
|i_<ScrollWheelDown>|	<ScrollWheelDown>	窗口向下滚动三行
|i_<S-ScrollWheelDown>|	<S-ScrollWheelDown>	窗口向下滚动完整一页
|i_<ScrollWheelUp>|	<ScrollWheelUp>		窗口向上滚动三行
|i_<S-ScrollWheelUp>|	<S-ScrollWheelUp>	窗口向上滚动完整一页
|i_<ScrollWheelLeft>|	<ScrollWheelLeft>	窗口向左滚动六列
|i_<S-ScrollWheelLeft>|	<S-ScrollWheelLeft>	窗口向左滚动完整一页
|i_<ScrollWheelRight>|	<ScrollWheelRight>	窗口向右滚动六列
|i_<S-ScrollWheelRight>| <S-ScrollWheelRight>	窗口向右滚动完整一页

CTRL-X 子模式的命令					*i_CTRL-X_index*

|i_CTRL-X_CTRL-D|	CTRL-X CTRL-D	补全定义过的标识符
|i_CTRL-X_CTRL-E|	CTRL-X CTRL-E	上滚
|i_CTRL-X_CTRL-F|	CTRL-X CTRL-F	补全文件名
|i_CTRL-X_CTRL-I|	CTRL-X CTRL-I	补全标识符
|i_CTRL-X_CTRL-K|	CTRL-X CTRL-K	从字典补全标识符
|i_CTRL-X_CTRL-L|	CTRL-X CTRL-L	补全完整的行
|i_CTRL-X_CTRL-N|	CTRL-X CTRL-N	下一个补全
|i_CTRL-X_CTRL-O|	CTRL-X CTRL-O	全能 (omni) 补全
|i_CTRL-X_CTRL-P|	CTRL-X CTRL-P	上一个补全
|i_CTRL-X_CTRL-S|	CTRL-X CTRL-S	拼写建议
|i_CTRL-X_CTRL-T|	CTRL-X CTRL-T	从同义词词典补全标识符
|i_CTRL-X_CTRL-U|	CTRL-X CTRL-U	用 'completefunc' 补全
|i_CTRL-X_CTRL-V|	CTRL-X CTRL-V	如同 : 命令行那样补全
|i_CTRL-X_CTRL-Y|	CTRL-X CTRL-Y	下滚
|i_CTRL-X_CTRL-]|	CTRL-X CTRL-]	补全标签
|i_CTRL-X_s|		CTRL-X s	拼写建议
{仅当编译时加入 |+insert_expand| 特性才有效}

==============================================================================
2. 普通模式						*normal-index*

CHAR	 任何非空白字符
WORD	 非空白字符的序列 (字串)
N	 命令前输入的数值
{motion} 光标移动命令
Nmove	 {motion} 移动经过的文本
SECTION	 可能以 '}' 而不是 '{' 开始的小节

备注: 1 = 光标移动命令；2 = 可以撤消/重做

标签		字符	      备注 普通模式的动作	~
------------------------------------------------------------------------------
		CTRL-@		   不用
|CTRL-A|	CTRL-A		2  把 N 加到光标所在/之后的数值上
|CTRL-B|	CTRL-B		1  反向 (Back) 滚动 N 屏
|CTRL-C|	CTRL-C		   终止当前的 (搜索) 命令
|CTRL-D|	CTRL-D		   向下 (Down) 滚动 N 行 (缺省: 半屏)
|CTRL-E|	CTRL-E		   向上滚动 N 行 (附加 (Extra) N 行)
|CTRL-F|	CTRL-F		1  向前 (Forward) 滚动 N 屏
|CTRL-G|	CTRL-G		   显示当前文件名和位置
|<BS>|		<BS>		1  等同于 "h"
|CTRL-H|	CTRL-H		1  等同于 "h"
|<Tab>|		<Tab>		1  跳转到跳转表里第 N 个较新的项目
|CTRL-I|	CTRL-I		1  等同于 <Tab>
|<NL>|		<NL>		1  等同于 "j"
|CTRL-J|	CTRL-J		1  等同于 "j"
		CTRL-K		   不用
|CTRL-L|	CTRL-L		   重画屏幕
|<CR>|		<CR>		1  光标移到 N 行下面的第一个 CHAR
|CTRL-M|	CTRL-M		1  等同于 <CR>
|CTRL-N|	CTRL-N		1  等同于 "j"
|CTRL-O|	CTRL-O		1  跳转到跳转表里第 N 个较旧的项目
|CTRL-P|	CTRL-P		1  等同于 "k"
		CTRL-Q		   (用于终端控制流)
|CTRL-R|	CTRL-R		2  重做 'u' 撤消的改变
		CTRL-S		   (用于终端控制流)
|CTRL-T|	CTRL-T		   跳转到标签列表的第 N 个较老的标签 (Tag)
|CTRL-U|	CTRL-U		   上滚 (Upwards) N 行 (缺省: 半屏)
|CTRL-V|	CTRL-V		   开始面向列块的可视 (Visual) 模式
|CTRL-W|	CTRL-W {char}	   窗口命令，见 |CTRL-W|
|CTRL-X|	CTRL-X		2  从光标所在/之后的数值上减去 N
|CTRL-Y|	CTRL-Y		   下滚 N 行
|CTRL-Z|	CTRL-Z		   暂停程序 (或者启动新的外壳)
		CTRL-[ <Esc>	   不用
|CTRL-\_CTRL-N| CTRL-\ CTRL-N	   进入普通 (Normal) 模式 (空动作)
|CTRL-\_CTRL-G| CTRL-\ CTRL-G	   进入 'insertmode' 指定的模式
		CTRL-\ a - z	   保留作扩展用
		CTRL-\ 其它        不用
|CTRL-]|	CTRL-]		   :ta 到光标所在的标识符
|CTRL-^|	CTRL-^		   编辑第 N 个轮换文件 (等价于 ":e #N")
		CTRL-_		   不用

|<Space>|	<Space>		1  等同于 "l"
|!|		!{motion}{filter}
				2  通过 {filter} 命令过滤 Nmove 文本
|!!|		!!{filter}	2  通过 {filter} 命令过滤 N 行
|quote|		"{a-zA-Z0-9.%#:-"}  指定下次删除、抽出或放置使用的寄存器
				   {a-zA-Z0-9.%#:-"} (大写用于添加)
				   ({.%#:} 只能用于放置)
|#|		#		1  反向搜索第 N 次出现的光标所在的标识符
|$|		$		1  光标移动到往下第 N 行的行尾之后
|%|		%		1  查找本行下一个 (花/方) 括号，并转到其匹配的
				   括号上，或者转到匹配的注释配对上，或者转到
				   匹配的预处理命令上。
|N%|		{count}%	1  转到文件的百分之 N 的位置上
|&|		&		2  重复上次 :s
|'|		'{a-zA-Z0-9}	1  光标移动到位置标记 {a-zA-Z0-9} 所在行的第一
				   个 CHAR 上
|''|		''		1  光标移动到最近一次跳转之前所在行的第一个
				   CHAR 上
|'(|		'(		1  光标移动到当前句子的首部所在行的第一个 CHAR
				   上
|')|		')		1  光标移动到当前句子的尾部所在行的第一个 CHAR
				   上
|'<|		'<		1  光标移动到当前缓冲区高亮区开始/曾经开始的行
				   的第一个 CHAR 上。
|'>|		'>		1  光标移动到当前缓冲区高亮区结束/曾经结束的行
				   的第一个 CHAR 上。
|'[|		'[		1  光标移动到当前缓冲区最近操作/放置的文本的首
				   部所在行的第一个 CHAR 上
|']|		']		1  光标移动到当前缓冲区最近操作/放置的文本的尾
				   部所在行的第一个 CHAR 上
|'{|		'{		1  光标移动到当前段落的首部所在行的第一个 CHAR
				   上
|'}|		'}		1  光标移动到当前段落的尾部所在行的第一个 CHAR
				   上
|(|		(		1  光标回退 N 个句子
|)|		)		1  光标前进 N 个句子
|star|		*		1  正向搜索第 N 次出现的光标所在的标识符
|+|		+		1  等同于 <CR>
|,|		,		1  反方向重复最近的 f、t、F 或 T N 次
|-|		-		1  光标移动到上方 N 行的第一个 CHAR 上
|.|		.		2  重复最近的改变，其计数被 N 取代
|/|		/{pattern}<CR>	1  正向搜索第 N 次出现的 {pattern}
|/<CR>|		/<CR>		1  正向搜索最近一次搜索使用的 {pattern}
|count|		0		1  光标移动到本行的第一个字符上
|count|		1		   附加于命令前，给出计数
|count|		2			"
|count|		3			"
|count|		4			"
|count|		5			"
|count|		6			"
|count|		7			"
|count|		8			"
|count|		9			"
|:|		:		1  开始进入 Ex 命令
|N:|		{count}:	   开始进入 Ex 命令，给出从当前行开始到下方
				   N-1 行为止的行范围
|;|		;		1  重复最近的 f、t、F 或 T N 次
|<|		<{motion}	2  左移 Nmove 文本行一个 'shiftwidth'
|<<|		<<		2  左移 N 行一个 'shiftwidth'
|=|		={motion}	2  通过 "indent" 过滤 Nmove 文本行
|==|		==		2  通过 "indent" 过滤 N 行
|>|		>{motion}	2  右移 Nmove 文本行一个 'shiftwidth'
|>>|		>>		2  右移 N 行一个 'shiftwidth'
|?|		?{pattern}<CR>	1  反向搜索第 N 次出现的 {pattern}
|?<CR>|		?<CR>		1  反向搜索最近一次搜索使用的 {pattern}
|@|		@{a-z}		2  执行 {a-z} 寄存器的内容 N 次
|@:|		@:		   重复上次的 ":" 命令 N 次
|@@|		@@		2  重复上次的 @{a-z} N 次
|A|		A		2  在行尾附加文本 N 次
|B|		B		1  光标反向移动 N 个 WORD (字串)
|C|		["x]C		2  从光标位置到行尾部分，再加上 N-1 行进行修改
				   [到缓冲区 (译者注: 应为寄存器，下同) x]；等
				   价于 "c$"
|D|		["x]D		2  删除位置到行尾部分，再加上 N-1 行的字符 [到
				   缓冲区 (见上) x]；等价于 "d$"
|E|		E		1  光标正向移动到第 N 个 WORD 的结束处
|F|		F{char}		1  光标左移到第 N 次出现的 {char} 上
|G|		G		1  光标移动到第 N 行，缺省是最后一行
|H|		H		1  光标移动到屏幕顶部开始算的第 N 行
|I|		I		2  在本行第一个 CHAR 之前插入文本 N 次
|J|		J		2  连接 (Join) N 行；缺省为 2
|K|		K		   查找光标所在的关键字 (Keyword)，使用
				   'keywordprg' 的定义
|L|		L		1  光标移动到屏幕底部开始算的第 N 行
|M|		M		1  光标移动到屏幕的中间一行
|N|		N		1  反方向重复最近的 '/' 或 '?' N 次
|O|		O		2  在光标上方开始一个新行，并插入文本，重复 N
				   次
|P|		["x]P		2  在光标放置文本 [到缓冲区 (见上) x] N 次
|Q|		Q		   切换到 "Ex" 模式
|R|		R		2  进入替换模式: 覆盖存在的字符，重复输入文本
				   N-1 次
|S|		["x]S		2  删除 N 行 [到缓冲区 (见上) x]] 并开始输入；
				   等价于 "cc"
|T|		T{char}		1  光标移动到左侧第 N 次出现的 {char} 之前
|U|		U		2  撤消一行内所有最近的改变
|V|		V		   进入面向行的可视 (Visual) 模式
|W|		W		1  光标前移 N 个 WORD
|X|		["x]X		2  删除光标前的 N 个字符 [到缓冲区 (见上) x]
|Y|		["x]Y		   抽出 N 行 [到缓冲区 (见上) x]；等价于 "yy"
|ZZ|		ZZ		   如果修改过，保存当前文件，然后退出
|ZQ|		ZQ		   无论如何退出当前文件
|[|		[{char}		   方括号命令 (见下 |[|)
		\		   不用
|]|		]{char}		   方括号命令 (见下 |]|)
|^|		^		1  光标移动到本行的第一个 CHAR 上
|_|		_		1  光标移动到下方第 N - 1 行的第一个 CHAR 上
|`|		`{a-zA-Z0-9}	1  光标移动到位置标记 {a-zA-Z0-9}
|`(|		`(		1  光标移动当前句子的开始处
|`)|		`)		1  光标移动当前句子的结束处
|`<|		`<		1  光标移动高亮区域的开始处
|`>|		`>		1  光标移动高亮区域的结束处
|`[|		`[		1  光标移动最近一次操作/放置的文本的开始处
|`]|		`]		1  光标移动最近一次操作/放置的文本的结束处
|``|		``		1  光标移动最近一次跳转的位置
|`{|		`{		1  光标移动当前段落的开始处
|`}|		`}		1  光标移动当前段落的结束处
|a|		a		2  在光标处附加文本 N 次
|b|		b		1  光标反向移动 N 个单词
|c|		["x]c{motion}	2  删除 Nmove 文本 [到缓冲区 (见上) x] 并开始
				   编辑
|cc|		["x]cc		2  删除 N 行 [到缓冲区 (见上) x] 并开始编辑
|d|		["x]d{motion}	2  删除 Nmove 文本 [到缓冲区 (见上) x]
|dd|		["x]dd		2  删除 N 行 [到缓冲区 (见上) x]]
|do|		do		2  等同于 ":diffget"
|dp|		dp		2  等同于 ":diffput"
|e|		e		1  光标正向移动到第 N 个单词的结束处
|f|		f{char}		1  光标右移到第 N 次出现的 {char} 上
|g|		g{char}		   扩展命令，见下 |g|
|h|		h		1  光标左移 N 个字符
|i|		i		2  在光标前插入文本 N 次
|j|		j		1  光标下移 N 行
|k|		k		1  光标上移 N 行
|l|		l		1  光标右移 N 个字符
|m|		m{A-Za-z}	   在光标位置处设置位置标记 {A-Za-z}
|n|		n		1  重复最近的 '/' 或 '?' N 次
|o|		o		2  在光标下方开始一个新行，并插入文本，重复 N
				   次
|p|		["x]p		2  在光标后放置文本 [从寄存器 x] N 次
|q|		q{0-9a-zA-Z"}	   记录输入的字符到命令寄存器 {0-9a-zA-Z"}
				   (大写用于添加)
|q|		q		   (在记录时) 停止记录
|q:|		q:		   在命令行窗口里编辑 : 命令行
|q/|		q/		   在命令行窗口里编辑 / 命令行
|q?|		q?		   在命令行窗口里编辑 ? 命令行
|r|		r{char}		2  用 {char} 替换 N 个字符
|s|		["x]s		2  (替换) 删除 N 个字符 [到缓冲区 (见上) x] 并
				   开始输入
|t|		t{char}		1  光标移动到右侧第 N 次出现的 {char} 之前
|u|		u		2  撤消改变
|v|		v		   开始面向字符的可视 (Visual) 模式
|w|		w		1  光标前移 N 个单词
|x|		["x]x		2  删除光标开始的 N 个字符 [到缓冲区 (见上) x]
|y|		["x]y{motion}	   抽出 Nmove 文本 [到缓冲区 (见上) x]
|yy|		["x]yy		   抽出 N 行 [到缓冲区 (见上) x]
|z|		z{char}		   'z' 开始的命令，见下 |z|
|{|		{		1  光标反向移动 N 个段落
|bar|		|		1  光标移到第 N 列
|}|		}		1  光标正向移动 N 个段落
|~|		~		2  'tildeop' 关闭时: 切换光标所在处开始的 N 个
				   字符的大小写，并右移光标 N 个字符
|~|		~{motion}	   'tildeop' 打开时: 切换 Nmove 文本的大小写
|<C-End>|	<C-End>		1  等同于 "G"
|<C-Home>|	<C-Home>	1  等同于 "gg"
|<C-Left>|	<C-Left>	1  等同于 "b"

|<C-LeftMouse>|	<C-LeftMouse>	   ":ta" 到鼠标点击所在的单词上
|<C-Right>|	<C-Right>	1  等同于 "w"
|<C-RightMouse>| <C-RightMouse>	   等同于 "CTRL-T"
|<Del>|		["x]<Del>	2  等同于 "x"
|N<Del>|	{count}<Del>	   删除 {count} 最后的一位数字
|<Down>|	<Down>		1  等同于 "j"
|<End>|		<End>		1  等同于 "$"
|<F1>|		<F1>		   等同于 <Help>
|<Help>|	<Help>		   打开帮助窗口
|<Home>|	<Home>		1  等同于 "0"
|<Insert>|	<Insert>	2  等同于 "i"
|<Left>|	<Left>		1  等同于 "h"
|<LeftMouse>|	<LeftMouse>	1  移动光标到鼠标点击处
|<MiddleMouse>| <MiddleMouse>	2  等同于在鼠标点击处 "gP"
|<PageDown>|	<PageDown>	   等同于 CTRL-F
|<PageUp>|	<PageUp>	   等同于 CTRL-B
|<Right>|	<Right>		1  等同于 "l"
|<RightMouse>|	<RightMouse>	   开始可视模式，移动光标到鼠标点击处
|<S-Down>|	<S-Down>	1  等同于 CTRL-F
|<S-Left>|	<S-Left>	1  等同于 "b"
|<S-LeftMouse>|	<S-LeftMouse>	   等同于在鼠标点击处 "*"
|<S-Right>|	<S-Right>	1  等同于 "w"
|<S-RightMouse>| <S-RightMouse>	   等同于在鼠标点击处 "#"
|<S-Up>|	<S-Up>		1  等同于 CTRL-B
|<Undo>|	<Undo>		2  等同于 "u"
|<Up>|		<Up>		1  等同于 "k"
|<ScrollWheelDown>|	<ScrollWheelDown>	窗口向下滚动三行
|<S-ScrollWheelDown>|	<S-ScrollWheelDown>	窗口向下滚动完整一页
|<ScrollWheelUp>|	<ScrollWheelUp>		窗口向上滚动三行
|<S-ScrollWheelUp>|	<S-ScrollWheelUp>	窗口向上滚动完整一页
|<ScrollWheelLeft>|	<ScrollWheelLeft>	窗口向左滚动六列
|<S-ScrollWheelLeft>|	<S-ScrollWheelLeft>	窗口向左滚动完整一页
|<ScrollWheelRight>|	<ScrollWheelRight>	窗口向右滚动六列
|<S-ScrollWheelRight>|	<S-ScrollWheelRight>	窗口向右滚动完整一页

==============================================================================
2.1 文本对象							*objects*

他们可以用在操作符之后，或者在可视模式里选择一个对象。

标签		命令		   操作符等待和可视模式下的动作 ~
------------------------------------------------------------------------------
|v_aquote|	a"		   双引号字符串
|v_a'|		a'		   单引号字符串
|v_a(|		a(		   等同于 ab
|v_a)|		a)		   等同于 ab
|v_a<|		a<		   "一个 <> 块" 从 '<' 到匹配的 '>'
|v_a>|		a>		   等同于 a<
|v_aB|		aB		   "一个大块" 从 "[{" 到 "]}" (带上括号)
|v_aW|		aW		   "一个字串" (带上空白)
|v_a[|		a[		   "一个 [] 块" 从 '[' 到匹配的 ']'
|v_a]|		a]		   等同于 a[
|v_a`|		a`		   反引号字符串
|v_ab|		ab		   "一个块" 从 "[(" 到 "])" (带上括号)
|v_ap|		ap		   "一个段落" (带上空白)
|v_as|		as		   "一个句子" (带上空白)
|v_at|		at		   "一个标签块" (带上空白)
|v_aw|		aw		   "一个单词" (带上空白)
|v_a{|		a{		   等同于 aB
|v_a}|		a}		   等同于 aB
|v_iquote|	i"		   双引号字符串，不带引号
|v_i'|		i'		   单引号字符串，不带引号
|v_i(|		i(		   等同于 ib
|v_i)|		i)		   等同于 ib
|v_i<|		i<		   "内含 <> 块" 从 '<' 到匹配的 '>'
|v_i>|		i>		   等同于 i<
|v_iB|		iB		   "内含大块" 从 "[{" 到 "]}"
|v_iW|		iW		   "内含字串"
|v_i[|		i[		   "内含 [] 块" 从 '[' 到匹配的 ']'
|v_i]|		i]		   等同于 i[
|v_i`|		i`		   反引号字符串，不带反引号
|v_ib|		ib		   "内含块" 从 "[(" 到 "])"
|v_ip|		ip		   "内含段落"
|v_is|		is		   "内含句子"
|v_it|		it		   "内含标签块"
|v_iw|		iw		   "内含单词"
|v_i{|		i{		   等同于 iB
|v_i}|		i}		   等同于 iB

==============================================================================
2.2 窗口命令							*CTRL-W*

标签		命令		   普通模式下的动作	~
------------------------------------------------------------------------------
|CTRL-W_CTRL-B|	CTRL-W CTRL-B	   等同于 "CTRL-W b"
|CTRL-W_CTRL-C|	CTRL-W CTRL-C	   等同于 "CTRL-W c"
|CTRL-W_CTRL-D|	CTRL-W CTRL-D	   等同于 "CTRL-W d"
|CTRL-W_CTRL-F|	CTRL-W CTRL-F	   等同于 "CTRL-W f"
		CTRL-W CTRL-G	   等同于 "CTRL-W g .."
|CTRL-W_CTRL-H|	CTRL-W CTRL-H	   等同于 "CTRL-W h"
|CTRL-W_CTRL-I|	CTRL-W CTRL-I	   等同于 "CTRL-W i"
|CTRL-W_CTRL-J|	CTRL-W CTRL-J	   等同于 "CTRL-W j"
|CTRL-W_CTRL-K|	CTRL-W CTRL-K	   等同于 "CTRL-W k"
|CTRL-W_CTRL-L|	CTRL-W CTRL-L	   等同于 "CTRL-W l"
|CTRL-W_CTRL-N|	CTRL-W CTRL-N	   等同于 "CTRL-W n"
|CTRL-W_CTRL-O|	CTRL-W CTRL-O	   等同于 "CTRL-W o"
|CTRL-W_CTRL-P|	CTRL-W CTRL-P	   等同于 "CTRL-W p"
|CTRL-W_CTRL-Q|	CTRL-W CTRL-Q	   等同于 "CTRL-W q"
|CTRL-W_CTRL-R|	CTRL-W CTRL-R	   等同于 "CTRL-W r"
|CTRL-W_CTRL-S|	CTRL-W CTRL-S	   等同于 "CTRL-W s"
|CTRL-W_CTRL-T|	CTRL-W CTRL-T	   等同于 "CTRL-W t"
|CTRL-W_CTRL-V|	CTRL-W CTRL-V	   等同于 "CTRL-W v"
|CTRL-W_CTRL-W|	CTRL-W CTRL-W	   等同于 "CTRL-W w"
|CTRL-W_CTRL-X|	CTRL-W CTRL-X	   等同于 "CTRL-W x"
|CTRL-W_CTRL-Z|	CTRL-W CTRL-Z	   等同于 "CTRL-W z"
|CTRL-W_CTRL-]|	CTRL-W CTRL-]	   等同于 "CTRL-W ]"
|CTRL-W_CTRL-^|	CTRL-W CTRL-^	   等同于 "CTRL-W ^"
|CTRL-W_CTRL-_|	CTRL-W CTRL-_	   等同于 "CTRL-W _"
|CTRL-W_+|	CTRL-W +	   增加当前窗口高度 N 行
|CTRL-W_-|	CTRL-W -	   减少当前窗口高度 N 行
|CTRL-W_<|	CTRL-W <	   减少当前窗口宽度 N 列
|CTRL-W_=|	CTRL-W =	   使得所有窗口同宽同高
|CTRL-W_>|	CTRL-W >	   增加当前窗口宽度 N 列
|CTRL-W_H|	CTRL-W H	   移动当前窗口到最左端
|CTRL-W_J|	CTRL-W J	   移动当前窗口到最底部
|CTRL-W_K|	CTRL-W K	   移动当前窗口到最顶部
|CTRL-W_L|	CTRL-W L	   移动当前窗口到最右端
|CTRL-W_P|	CTRL-W P	   跳转到预览窗口
|CTRL-W_R|	CTRL-W R	   向上旋转窗口 N 次
|CTRL-W_S|	CTRL-W S	   等同于 "CTRL-W s"
|CTRL-W_T|	CTRL-W T	   移动当前窗口到新标签页
|CTRL-W_W|	CTRL-W W	   跳转到前面第 N 个窗口 (回绕)
|CTRL-W_]|	CTRL-W ]	   分割窗口并跳转到光标所在的标签上
|CTRL-W_^|	CTRL-W ^	   分割窗口并编辑轮换文件 N
|CTRL-W__|	CTRL-W _	   设置当前窗口高度为 N (缺省: 尽量大)
|CTRL-W_b|	CTRL-W b	   跳转到底部的窗口
|CTRL-W_c|	CTRL-W c	   关闭当前窗口 (类似于 |:close|)
|CTRL-W_d|	CTRL-W d	   分割窗口并跳转到光标所在的定义上
|CTRL-W_f|	CTRL-W f	   分割窗口并跳转到光标所在的文件名上
|CTRL-W_F|	CTRL-W F	   分割窗口并编辑光标所在的文件名，然后跳转到
				   文件名后给出的行号上。
|CTRL-W_g_CTRL-]| CTRL-W g CTRL-]  分割窗口并在光标所在的标签上执行 |:tjump|
|CTRL-W_g]|	CTRL-W g ]	   分割窗口并在光标所在的标签上执行 |:tselect|
|CTRL-W_g}|	CTRL-W g }	   在光标所在的标签上执行 |:ptjump|
|CTRL-W_gf|	CTRL-W g f	   在新的标签页里编辑光标所在的文件名
|CTRL-W_gF|	CTRL-W g F	   在新的标签页里编辑光标所在的文件名然后跳转
				   到文件名后给出的行号上。
|CTRL-W_h|	CTRL-W h	   跳转到左面第 N 个的窗口 (在首个窗口上停止)
|CTRL-W_i|	CTRL-W i	   分割窗口并跳转到光标所在的标识符的声明上
|CTRL-W_j|	CTRL-W j	   跳转到下面第 N 个的窗口 (在最后窗口上停止)
|CTRL-W_k|	CTRL-W k	   跳转到上面第 N 个的窗口 (在首个窗口上停止)
|CTRL-W_l|	CTRL-W l	   跳转到右面第 N 个的窗口 (在最后窗口上停止)
|CTRL-W_n|	CTRL-W n	   打开新窗口，N 行高
|CTRL-W_o|	CTRL-W o	   关闭除了当前窗口以外的所有窗口 (类似于
				   |:only|)
|CTRL-W_p|	CTRL-W p	   转到前面一个 (最近访问的) 窗口
|CTRL-W_q|	CTRL-W q	   退出当前窗口 (类似于 |:quit|)
|CTRL-W_r|	CTRL-W r	   向下旋转窗口 N 次
|CTRL-W_s|	CTRL-W s	   分割当前窗口为两部分，新的窗口 N 行高
|CTRL-W_t|	CTRL-W t	   跳转到顶部窗口
|CTRL-W_v|	CTRL-W v	   垂直分割当前窗口，新的窗口 N 列宽
|CTRL-W_w|	CTRL-W w	   转到后面第 N 个窗口 (回绕)
|CTRL-W_x|	CTRL-W x	   交换当前和第 N 个窗口 (缺省: 下一个窗口)
|CTRL-W_z|	CTRL-W z	   关闭预览窗口
|CTRL-W_bar|	CTRL-W |	   设置窗口宽度为 N 列
|CTRL-W_}|	CTRL-W }	   在预览窗口里显示光标所在的标签
|CTRL-W_<Down>|	CTRL-W <Down>	   等同于 "CTRL-W j"
|CTRL-W_<Up>|	CTRL-W <Up>	   等同于 "CTRL-W k"
|CTRL-W_<Left>|	CTRL-W <Left>	   等同于 "CTRL-W h"
|CTRL-W_<Right>| CTRL-W <Right>	   等同于 "CTRL-W l"

==============================================================================
2.3 方括号命令							*[* *]*

标签		字符	      备注 普通模式下的动作	~
------------------------------------------------------------------------------
|[_CTRL-D|	[ CTRL-D	   跳转到第一个在当前文件和它包含的头文件里匹
				   配光标所在的单词的 #define，从当前文件的头
				   部开始
|[_CTRL-I|	[ CTRL-I	   跳转到第一个在当前文件和它包含的头文件里匹
				   配光标所在单词的位置，从当前文件头部开始
|[#|		[#		1  光标移动到前面第 N 个未匹配的 #if、#else 或
				   者 #ifdef
|['|		['		1  光标移动到前面的小写位置标记，定位在它所在
				   行的第一个非空白字符上
|[(|		[(		1  光标移动到前面第 N 个未匹配的 '('
|[star|		[*		1  等同于 "[/"
|[`|		[`		1  光标移动到前一个小写位置标记
|[/|		[/		1  光标移动到前面第 N 个 C 注释的开始处
|[D|		[D		   列出在当前文件和它包含的头文件里匹配光标所
				   在的单词的所有定义，从当前文件的头部开始
|[I|		[I		   列出在当前文件和它包含的头文件里匹配光标所
				   在单词的所有位置，从当前文件的头部开始
|[P|		[P		2  等同于 "[p"
|[[|		[[		1  光标后退 N 个小节
|[]|		[]		1  光标后退 N 个 SECTION
|[c|		[c		1  光标后退 N 个更改开始的地方
|[d|		[d		   显示第一个在当前文件和它包含的头文件里匹配
				   光标所在的单词的 #define，从当前文件的头部
				   开始
|[f|		[f		   等同于 "gf"
|[i|		[i		   显示第一个在当前文件和它包含的头文件里匹配
				   光标所在单词的位置，从当前文件的头部开始
|[m|		[m		1  光标后退 N 个成员函数的开始
|[p|		[p		2  类似于 "P"，但调整当前行的缩进
|[s|		[s		1  移动到前一个拼写错误的单词
|[z|		[z		1  移动到打开的折叠的开始
|[{|		[{		1  光标后退 N 个未匹配的 '{'
|[<MiddleMouse>| [<MiddleMouse>	2  等同于 "[p"

|]_CTRL-D|	] CTRL-D	   跳转到第一个在当前文件和它包含的头文件里匹
				   配光标所在的单词的 #define，从光标位置开始
|]_CTRL-I|	] CTRL-I	   跳转到第一个在当前文件和它包含的头文件里匹
				   配光标所在单词的位置，从光标位置开始
|]#|		]#		1  光标移动到后面第 N 个未匹配的 #endif、#else
|]'|		]'		1  光标移动到后面的小写位置标记，定位在它所在
				   行的第一个非空白字符上
|])|		])		1  光标移动到后面第 N 个未匹配的 ')'
|]star|		]*		1  等同于 "]/"
|]`|		]`		1  光标移动到后一个小写位置标记
|]/|		]/		1  光标移动到后面第 N 个 C 注释的结尾处
|]D|		]D		   列出在当前文件和它包含的头文件里匹配光标所
				   在的单词的所有定义，从光标位置开始
|]I|		]I		   列出在当前文件和它包含的头文件里匹配光标所
				   在单词的所有位置，从光标位置开始
|]P|		]P		2  等同于 "[p"
|][|		][		1  光标前进 N 个小节
|]]|		]]		1  光标前进 N 个 SECTION
|]c|		]c		1  光标前进 N 个更改开始的地方
|]d|		]d		   显示第一个在当前文件和它包含的头文件里匹配
				   光标所在的单词的 #define，从光标位置开始
|]f|		]f		   等同于 "gf"
|]i|		]i		   显示第一个在当前文件和它包含的头文件里匹配
				   光标所在单词的位置，从光标位置开始
|]m|		]m		1  光标前进 N 个成员函数的结尾
|]p|		]p		2  类似于 "p"，但调整当前行的缩进
|]s|		]s		1  移动到后一个拼写错误的单词
|]z|		]z		1  移动到打开的折叠的结尾处
|]}|		]}		1  光标前进 N 个未匹配的 '}'
|]<MiddleMouse>| ]<MiddleMouse>	2  等同于 "]p"

==============================================================================
2.4 'g' 开始的命令						*g*

标签		字符	      备注 普通模式下的动作	~
------------------------------------------------------------------------------
|g_CTRL-A|	g CTRL-A	   只有在编译时加入了 MEM_PROFILE 时才有定义:
				   转储内存内容
|g_CTRL-G|	g CTRL-G	   显示当前光标位置
|g_CTRL-H|	g CTRL-H	   启动选择列块模式
|g_CTRL-]|	g CTRL-]	   |:tjump| 到光标所在的标签上
|g#|		g#		1  类似于 "#"，但不使用 "\<" 和 "\>"
|g$|		g$		1  'wrap' 关闭时转到当前行最右侧屏幕上可见的字
				   符
				   'wrap' 打开时转到当前屏幕行最右侧的字符
|g&|		g&		2  在所有行上重复上次的 ":s"
|g'|		g'{mark}	1  类似于 |'|，但不改变跳转表
|g`|		g`{mark}	1  类似于 |`|，但不改表跳转表
|gstar|		g*		1  类似于 "*"，但不使用 "\<" 和 "\>"
|g0|		g0		1  'wrap' 关闭时转到当前行最左侧屏幕上可见的字
				   符
				   'wrap' 打开时转到当前屏幕行最左侧的字符
|g8|		g8		   显示光标所在的 UTF-8 字符的十六进制字节码
|g<|		g<		   显示上次的命令输出
|g?|		g?		2  Rot13 编码操作符
|g?g?|		g??		2  Rot13 编码当前行
|g?g?|		g?g?		2  Rot13 编码当前行
|gD|		gD		1  转到当前文件的光标所在单词的定义
|gE|		gE		1  反向转移到上一个 WORD 的结尾处
|gH|		gH		   启动选择行模式
|gI|		gI		2  类似于 "I"，但总是从第一列开始
|gJ|		gJ		2  连接行，不插入空格
|gN|		gN	      1,2  使用前次搜索模式搜索上一个匹配，并可视选择
				   之
|gP|		["x]gP		2  在光标签放置文本 [从寄存器 x] N 次，光标留
				   在插入文本之后
|gQ|		gQ		   Vim 编辑时进入 "Ex" 模式
|gR|		gR		2  进入虚拟替换模式
|gT|		gT		   转到前一个标签页
|gU|		gU{motion}	2  使得 Nmove 文本全部大写
|gV|		gV		   在执行选择模式下的映射或者菜单时，不要重复
				   选择过去的可视区域
|g]|		g]		   :tselect 到光标所在的标签上
|g^|		g^		1  'wrap' 关闭时转到当前行最左侧屏幕上可见的非
				   空白字符
				   'wrap' 打开时转到当前屏幕行最左侧的非空白字
				   符
|ga|		ga		   打印光标所在处的字符的 ascii 值
|gd|		gd		1  转到当前函数里当前光标所在的单词的定义
|ge|		ge		1  反向转到前一个单词的结尾处
|gf|		gf		   开始编辑当前光标所在的名字对应的文件
|gF|		gF		   开始编辑光标所在的文件名并跳转到文件名后的
				   行号上。
|gg|		gg		1  光标移动到第 N 行，缺省是第一行
|gh|		gh		   开始选择模式
|gi|		gi		2  类似于 "i"，但先移动到 |'^| 位置标记
|gj|		gj		1  类似于 "j"，但 'wrap' 打开时往下 N 个屏幕行
|gk|		gk		1  类似于 "k"，但 'wrap' 打开时往上 N 个屏幕行
|gm|		gm		1  转到屏幕行正中间的那个字符
|gn|		gn	      1,2  使用前次搜索模式搜索下一个匹配，并可视选择
				   之
|go|		go		1  光标移动到缓冲区的第 N 个字节
|gp|		["x]gp		2  在光标后面放置文本 [从寄存器 x] N 次，光标
				   留在后面
|gq|		gq{motion}	2  排版 Nmove 文本
|gr|		gr{char}	2  虚拟替换 N 个字符为 {char}
|gs|		gs		   睡眠 N 秒 (缺省 1)
|gt|		gt		   转到下一个标签页
|gu|		gu{motion}	2  使得 Nmove 文本全部小写
|gv|		gv		   重新选择上次的可视区域
|gw|		gw{motion}	2  排版 Nmove 文本并保持光标位置
|netrw-gx|	gx		   执行光标下的文件名对应的应用程序 (仅限于
				   |netrw| 插件)
|g@|		g@{motion}	   调用 'operatorfunc'
|g~|		g~{motion}	2  改变 Nmove 文本的大小写
|g<Down>|	g<Down>		1  等同于 "gj"
|g<End>|	g<End>		1  等同于 "g$"
|g<Home>|	g<Home>		1  等同于 "g0"
|g<LeftMouse>|	g<LeftMouse>	   等同于 <C-LeftMouse>
		g<MiddleMouse>	   等同于 <C-MiddleMouse>
|g<RightMouse>|	g<RightMouse>	   等同于 <C-RightMouse>
|g<Up>|		g<Up>		1  等同于 "gk"

==============================================================================
2.5 'z' 开始的命令						*z*

标签		字符	      备注 普通模式下的动作	~
------------------------------------------------------------------------------
|z<CR>|		z<CR>		   重画，光标移动到窗口的顶行的第一个非空白字
				   符
|zN<CR>|	z{height}<CR>	   重画，使得窗口高度为 {height} 行
|z+|		z+		   光标移动到第 N 行 (缺省为窗口之后的第一
				   行)，其它同 "z<CR>"
|z-|		z-		   重画，光标移动到窗口末行的第一个非空白字符
|z.|		z.		   重画，光标移动到窗口的中间行的第一个非空白
				   字符
|z=|		z=		   给出拼写建议
|zA|		zA		   递归打开一个关闭的折叠或关闭一个打开的折叠
|zC|		zC		   递归关闭折叠
|zD|		zD		   递归删除折叠
|zE|		zE		   除去所有折叠
|zF|		zF		   为 N 行建立折叠
|zG|		zG		   把单词标记为拼写正确 (good)
|zH|		zH		   'wrap' 关闭时向右滚屏半个屏幕宽度
|zL|		zL		   'wrap' 关闭时向左滚屏半个屏幕宽度
|zM|		zM		   设置 'foldlevel' 为零
|zN|		zN		   置位 'foldenable'
|zO|		zO		   递归打开折叠
|zR|		zR		   设置 'foldlevel' 为最大折叠级别
|zW|		zW		   把单词标记为拼写错误 (wrong)
|zX|		zX		   重新应用 'foldlevel'
|z^|		z^		   光标移动到第 N 行 (缺省为窗口之前的一行)，
				   其它同 "z-"
|za|		za		   打开关闭的折叠，或关闭打开的折叠
|zb|		zb		   重画，光标在窗口底行
|zc|		zc		   关闭折叠
|zd|		zd		   删除折叠
|ze|		ze		   'wrap' 关闭时，水平滚动使得光标定位到屏幕的
				   尾部 (最右侧)
|zf|		zf{motion}	   为 Nmove 文本建立折叠
|zg|		zg		   把单词标记为拼写正确 (good)
|zh|		zh		   'wrap' 关闭时，水平右滚屏幕 N 个字符
|zi|		zi		   切换 'foldenable'
|zj|		zj		1  移动到下一个折叠的开始处
|zk|		zk		1  移动到前一个折叠的结束处
|zl|		zl		   'wrap' 关闭时，水平左滚屏幕 N 个字符
|zm|		zm		   从 'foldlevel' 减一
|zn|		zn		   复位 'foldenable'
|zo|		zo		   打开折叠
|zr|		zr		   给 'foldlevel' 加一
|zs|		zs		   'wrap' 关闭时，水平滚动使得光标定位到屏幕的
				   起始处 (最左侧)
|zt|		zt		   重画，光标移动到窗口的顶部
|zw|		zw		   把单词标记为拼写错误 (wrong)
|zv|		zv		   打开足够的折叠，使得当前行可见
|zx|		zx		   重新应用 'foldlevel' 然后执行 "zv"
|zz|		zz		   重画，光标移动到窗口的中间行
|z<Left>|	z<Left>		   等同于 "zh"
|z<Right>|	z<Right>	   等同于 "zl"

==============================================================================
3. 可视模式						*visual-index*

可视模式下，大多数命令同普通模式的相同。以下列出的是不同的部分。

标签		字符	      备注 可视模式下的动作	~
------------------------------------------------------------------------------
|v_CTRL-\_CTRL-N| CTRL-\ CTRL-N	   结束可视模式
|v_CTRL-\_CTRL-G| CTRL-\ CTRL-G	   转到 'insertmode' 指定的模式
|v_CTRL-C|	CTRL-C		   结束可视模式
|v_CTRL-G|	CTRL-G		   在可视模式和选择模式间切换
|v_<BS>|	<BS>		2  选择模式: 删除高亮区域
|v_CTRL-H|	CTRL-H		2  等同于 <BS>
|v_CTRL-O|	CTRL-O		   从选择模式切换到可视模式，只限于下个命令
|v_CTRL-V|	CTRL-V		   使得可视模式面向列块，或者退出可视模式
|v_<Esc>|	<Esc>		   结束可视模式
|v_CTRL-]|	CTRL-]		   跳转到高亮的标签上
|v_!|		!{filter}	2  通过外部命令 {filter} 过滤高亮行
|v_:|		:		   使用高亮行作为范围，开始一个命令行
|v_<|		<		2  左移高亮行一个 'shiftwidth'
|v_=|		=		2  用 {equalprg} 选项指定的外部程序过滤高亮行
|v_>|		>		2  右移高亮行一个 'shiftwidth'
|v_b_A|		A		2  列块模式下: 在高亮区域的所有行后附加相同的
				   文本
|v_C|		C		2  删除高亮行，并开始插入
|v_D|		D		2  删除高亮行
|v_b_I|		I		2  列块模式: 在所有高亮行之前插入相同的文本
|v_J|		J		2  连接高亮行
|v_K|		K		   在高亮区域上运行 'keywordprg'
|v_O|		O		   水平移动到区域的另外一侧
		Q		   不启动 Ex 模式
|v_R|		R		2  删除高亮行并开始插入
|v_S|		S		2  删除高亮行并开始插入
|v_U|		U		2  使得高亮区域全变大写
|v_V|		V		   使得可视区域面向行，或者退出可视模式
|v_X|		X		2  删除高亮区域
|v_Y|		Y		   抽出高亮行
|v_aquote|	a"		   扩展高亮区域，使包含一个双引号字符串
|v_a'|		a'		   扩展高亮区域，使包含一个单引号字符串
|v_a(|		a(		   等同于 ab
|v_a)|		a)		   等同于 ab
|v_a<|		a<		   扩展高亮区域，使包含一个 <> 块
|v_a>|		a>		   等同于 a<
|v_aB|		aB		   扩展高亮区域，使包含一个 {} 块
|v_aW|		aW		   扩展高亮区域，使包含 "一个 WORD"
|v_a[|		a[		   扩展高亮区域，使包含一个 [] 块
|v_a]|		a]		   等同于 a[
|v_a`|		a`		   扩展高亮区域，使包含一个反引号字符串
|v_ab|		ab		   扩展高亮区域，使包含一个 () 块
|v_ap|		ap		   扩展高亮区域，使包含一个段落
|v_as|		as		   扩展高亮区域，使包含一个句子
|v_at|		at		   扩展高亮区域，使包含一个标签块
|v_aw|		aw		   扩展高亮区域，使包含 "一个单词"
|v_a{|		a{		   等同于 aB
|v_a}|		a}		   等同于 aB
|v_c|		c		2  删除高亮区域，并开始插入
|v_d|		d		2  删除高亮区域
|v_gJ|		gJ		2  连接高亮行，不插入空格
|v_gq|		gq		2  排版高亮行
|v_gv|		gv		   交换现在和以前的高亮区域
|v_iquote|	i"		   扩展高亮区域，使包含一个双引号字符串 (但不
				   含引号)
|v_i'|		i'		   扩展高亮区域，使包含一个单引号字符串 (但不
				   含引号)
|v_i(|		i(		   等同于 ib
|v_i)|		i)		   等同于 ib
|v_i<|		i<		   扩展高亮区域，使包含内含 <> 块
|v_i>|		i>		   等同于 i<
|v_iB|		iB		   扩展高亮区域，使包含内含 {} 块
|v_iW|		iW		   扩展高亮区域，使包含 "内含 WORD"
|v_i[|		i[		   扩展高亮区域，使包含内含 [] 块
|v_i]|		i]		   等同于 i[
|v_i`|		i`		   扩展高亮区域，使包含一个反引号字符串 (但不
				   含反引号)
|v_ib|		ib		   扩展高亮区域，使包含内含 () 块
|v_ip|		ip		   扩展高亮区域，使包含内含段落
|v_is|		is		   扩展高亮区域，使包含内含句子
|v_it|		it		   扩展高亮区域，使包含内含标签块
|v_iw|		iw		   扩展高亮区域，使包含 "内含单词"
|v_i{|		i{		   等同于 iB
|v_i}|		i}		   等同于 iB
|v_o|		o		   移动光标到区域的另一侧
|v_r|		r		2  删除高亮区域，并开始插入
|v_s|		s		2  删除高亮区域，并开始插入
|v_u|		u		2  使得高亮区域全变小写
|v_v|		v		   使得可视模式面向字符，或者退出可视模式
|v_x|		x		2  删除高亮区域
|v_y|		y		   抽出高亮区域
|v_~|		~		2  改变高亮区域的大小写

==============================================================================
4. 命令行编辑						*ex-edit-index*

使用 ':'、'!'、'/' 或 '?' 命令进入命令行编辑。
输入普通字符会在当前光标位置插入该字符。
下面的 "补全" 指上下文相关的补全。如果可能，会补全文件名、标签、命令等。

标签		字符	       命令行编辑模式下的动作	~
------------------------------------------------------------------------------
		CTRL-@		不用
|c_CTRL-A|	CTRL-A		使用光标前面的模式进行补全，并插入所有的匹配
|c_CTRL-B|	CTRL-B		光标移动到命令行开始的地方
|c_CTRL-C|	CTRL-C		等同于 <Esc>
|c_CTRL-D|	CTRL-D		列出光标前面模式的所有补全
|c_CTRL-E|	CTRL-E		光标移动到命令行结束的地方
|'cedit'|	CTRL-F		'cedit' 的缺省值: 打开命令行窗口；否则不用
		CTRL-G		不用
|c_<BS>|	<BS>		删除光标前面的字符
|c_digraph|	{char1} <BS> {char2}
				'digraph' 打开时，输入二合字母
|c_CTRL-H|	CTRL-H		等同于 <BS>
|c_<Tab>|	<Tab>		如果 'wildchar' 是 <Tab>: 补全光标前面的模式
|c_<S-Tab>|	<S-Tab>		等同于 CTRL-P
|c_wildchar|	'wildchar'	补全光标前面的模式 (缺省: <Tab>)
|c_CTRL-I|	CTRL-I		等同于 <Tab>
|c_<NL>|	<NL>		等同于 <CR>
|c_CTRL-J|	CTRL-J		等同于 <CR>
|c_CTRL-K|	CTRL-K {char1} {char2}
				输入二合字母
|c_CTRL-L|	CTRL-L		补全光标前的模式，并插入最长的公共子串
|c_<CR>|	<CR>		执行输入的命令
|c_<CR>|	CTRL-M		等同于 <CR>
|c_CTRL-N|	CTRL-N		使用 'wildchar' 并有多个匹配: 转到下一个匹配，
				不然: 等同于 <Down>
		CTRL-O		不同
|c_CTRL-P|	CTRL-P		使用 'wildchar' 并有多个匹配: 转到上一个匹配，
				不然: 等同于 <Up>
|c_CTRL-Q|	CTRL-Q		等同于 CTRL-V，除非用于终端控制流
|c_CTRL-R|	CTRL-R {0-9a-z"%#*:= CTRL-F CTRL-P CTRL-W CTRL-A}
				插入寄存器的内容或特殊对象到光标所在的地方，如
				同直接输入那样
|c_CTRL-R_CTRL-R| CTRL-R CTRL-R {0-9a-z"%#*:= CTRL-F CTRL-P CTRL-W CTRL-A}
				按本义插入寄存器的内容或特殊对象到光标所在的地
				方
		CTRL-S		(用于终端控制流)
		CTRL-T		不用
|c_CTRL-U|	CTRL-U		删除所有字符
|c_CTRL-V|	CTRL-V		按本义插入下一个非数字字符，或者插入其后三位数
				字所代表的单个字节。
|c_CTRL-W|	CTRL-W		删除光标前面的单词
		CTRL-X		不用 (保留作补全用)
		CTRL-Y		复制 (抽出) 无模式的选择
		CTRL-Z		不用 (保留作暂停用)
|c_<Esc>|	<Esc>		放弃命令行，不执行
|c_<Esc>|	CTRL-[		等同于 <Esc>
|c_CTRL-\_CTRL-N| CTRL-\ CTRL-N	转到普通模式，放弃命令行
|c_CTRL-\_CTRL-G| CTRL-\ CTRL-G	转到 'insertmode' 指定的模式，放弃命令行
		CTRL-\ a - d	保留给扩展用
|c_CTRL-\_e|	CTRL-\ e {expr} 以 {expr} 的结果替换命令行
		CTRL-\ f - z	保留给扩展用
		CTRL-\ 其它	不用
|c_CTRL-]|	CTRL-]		激活缩写
|c_CTRL-^|	CTRL-^		切换 |:lmap| 映射的使用
|c_CTRL-_|	CTRL-_		'allowrevins'  打开时: 改变语言 (希伯来，波斯)
|c_<Del>|	<Del>		删除光标所在的字符

|c_<Left>|	<Left>		光标左移
|c_<S-Left>|	<S-Left>	光标左移一个单词
|c_<C-Left>|	<C-Left>	光标左移一个单词
|c_<Right>|	<Right>		光标右移
|c_<S-Right>|	<S-Right>	光标右移一个单词
|c_<C-Right>|	<C-Right>	光标右移一个单词
|c_<Up>|	<Up>		从历史中调入匹配光标前模式的前一个命令行
|c_<S-Up>|	<S-Up>		从历史中调入前一个命令行
|c_<Down>|	<Down>		从历史中调入匹配光标前模式的后一个命令行
|c_<S-Down>|	<S-Down>	从历史中调入后一个命令行
|c_<Home>|	<Home>		光标移动到命令行开始的地方
|c_<End>|	<End>		光标移动到命令行结束的地方
|c_<PageDown>|	<PageDown>	等同于 <S-Down>
|c_<PageUp>|	<PageUp>	等同于 <S-Up>
|c_<Insert>|	<Insert>	切换插入/替换模式
|c_<LeftMouse>|	<LeftMouse>	光标移动到鼠标点击的地方

亚瑟王，你找到 (圣杯) 了！			*holy-grail*

==============================================================================
5. EX 命令					*ex-cmd-index* *:index*

这里是一个简短但完整的 ":" 命令的列表。这里不讨论参数。命令可选的部分用 [] 括
起。命令按照名字非可选部分排序。

标签		字符	       动作	~
------------------------------------------------------------------------------
|:!|		:!		过滤行，或可通过外部命令执行之
|:!!|		:!!		重复上次的 ":!" 命令
|:#|		:#		等同于 ":number"
|:&|		:&		重复上次的 ":substitute"
|:star|		:*		执行寄存器的内容
|:<|		:<		将行左移一个 'shiftwidth'
|:=|		:=		显示光标所在的行号
|:>|		:>		将行右移一个 'shiftwidth'
|:@|		:@		执行寄存器的内容
|:@@|		:@@		重复上次的 ":@"
|:Next|		:N[ext]		转到参数列表的上一个文件
|:Print|	:P[rint]	显示行
|:X|		:X		请求加密密钥
|:append|	:a[ppend]	附加文本
|:abbreviate|	:ab[breviate]	输入缩写
|:abclear|	:abc[lear]	删除所有的缩写
|:aboveleft|	:abo[veleft]	使得分割的窗口出现在左侧或者上方
|:all|		:al[l]		为参数列表的每个文件打开一个窗口
|:amenu|	:am[enu]	为所有模式输入菜单项
|:anoremenu|	:an[oremenu]	为所有模式输入菜单项，不会被重新映射
|:args|		:ar[gs]		显示参数列表
|:argadd|	:arga[dd]	增加项目到参数列表中
|:argdelete|	:argd[elete]	从参数列表中删除项目
|:argedit|	:arge[dit]	增加项目到参数列表中并编辑之
|:argdo|	:argdo		在参数列表上的所有项目上执行一个命令
|:argglobal|	:argg[lobal]	定义全局参数列表
|:arglocal|	:argl[ocal]	定义本地参数列表
|:argument|	:argu[ment]	转到参数列表一个指定的文件
|:ascii|	:as[cii]	显示光标所在的字符的 ascii 值
|:autocmd|	:au[tocmd]	输入或者显示自动命令
|:augroup|	:aug[roup]	选择要用的自动命令组
|:aunmenu|	:aun[menu]	删除所有模式下的菜单
|:buffer|	:b[uffer]	转到缓冲区列表里的特定缓冲区
|:bNext|	:bN[ext]	转到缓冲区列表里的上一个缓冲区
|:ball|		:ba[ll]		为缓冲区列表里的每个缓冲区打开一个窗口
|:badd|		:bad[d]		增加缓冲区到缓冲区列表
|:bdelete|	:bd[elete]	从缓冲区列表删除缓冲区
|:behave|	:be[have]	设置鼠标和选择行为
|:belowright|	:bel[owright]	使得分割的窗口出现在右侧或者下方
|:bfirst|	:bf[irst]	转到缓冲区列表里的第一个缓冲区
|:blast|	:bl[ast]	转到缓冲区列表里的最后一个缓冲区
|:bmodified|	:bm[odified]	转到缓冲区列表里的下一个修改过的缓冲区
|:bnext|	:bn[ext]	转到缓冲区列表里的下一个缓冲区
|:botright|	:bo[tright]	使得分割的窗口出现在最右侧或者下方
|:bprevious|	:bp[revious]	转到缓冲区列表里的上一个缓冲区
|:brewind|	:br[ewind]	转到缓冲区列表里的第一个缓冲区
|:break|	:brea[k]	跳出 while 循环
|:breakadd|	:breaka[dd]	增加调试器断点
|:breakdel|	:breakd[el]	删除调试器断点
|:breaklist|	:breakl[ist]	列出调试器断点
|:browse|	:bro[wse]	使用文件选择对话框
|:bufdo|	:bufdo		为所有列表内缓冲区执行命令
|:buffers|	:buffers	列出缓冲区列表里的所有文件
|:bunload|	:bun[load]	卸载指定的缓冲区
|:bwipeout|	:bw[ipeout]	真正删除一个缓冲区
|:change|	:c[hange]	替换一行或若干行
|:cNext|	:cN[ext]	跳转到上一个错误
|:cNfile|	:cNf[ile]	跳转到前一个文件的最后一个错误
|:cabbrev|	:ca[bbrev]	类似于 ":abbreviate"，但用于命令行模式
|:cabclear|	:cabc[lear]	清除所有缩写，用于命令行模式
|:caddbuffer|	:caddb[uffer]	通过缓冲区补充错误
|:caddexpr|	:cad[dexpr]	通过表达式补充错误
|:caddfile|	:caddf[ile]	加入错误信息到当前 quickfix 列表
|:call|		:cal[l]		调用函数
|:catch|	:cat[ch]	:try 命令的一部分
|:cbuffer|	:cb[uffer]	分析错误信息并跳转到第一个
|:cc|		:cc		跳转到特定的错误
|:cclose|	:ccl[ose]	关闭 quickfix 窗口
|:cd|		:cd		改变目录
|:center|	:ce[nter]	排版行，使其居中对齐
|:cexpr|	:cex[pr]	从表达式里读取错误并跳转到第一个
|:cfile|	:cf[ile]	读入含有错误信息的文件，并跳转到第一个
|:cfirst|	:cfir[st]	跳转到指定的错误上，缺省为第一个
|:cgetbuffer|	:cgetb[uffer]	从缓冲区里得到错误
|:cgetexpr|	:cgete[xpr]	从表达实里得到错误
|:cgetfile|	:cg[etfile]	读入含有错误信息的文件
|:changes|	:changes	显示修改的列表
|:chdir|	:chd[ir]	改变当前目录
|:checkpath|	:che[ckpath]	列出包含的头文件
|:checktime|	:checkt[ime]	检查载入缓冲区的时间标签
|:clist|	:cl[ist]	列出所有错误
|:clast|	:cla[st]	跳转到指定的错误上，缺省为最后一个
|:close|	:clo[se]	改变当前窗口
|:cmap|		:cm[ap]		类似于 ":map"，但用于命令行模式
|:cmapclear|	:cmapc[lear]	清除所有映射，用于命令行模式
|:cmenu|	:cme[nu]	为命令行模式增加菜单
|:cnext|	:cn[ext]	跳转到下一个错误
|:cnewer|	:cnew[er]	跳转到下一个较新的错误列表
|:cnfile|	:cnf[ile]	跳转到下一个文件的第一个错误
|:cnoremap|	:cno[remap]	类似于 ":noremap"，但用于命令行模式
|:cnoreabbrev|	:cnorea[bbrev]	类似于 ":noreabbrev"，但用于命令行模式
|:cnoremenu|	:cnoreme[nu]	类似于 ":noremenu"，但用于命令行模式
|:copy|		:co[py]		复制行
|:colder|	:col[der]	跳转到上一个较老的错误列表
|:colorscheme|	:colo[rscheme]	载入特定的色彩方案
|:command|	:com[mand]	建立用户自定的命令
|:comclear|	:comc[lear]	清除所有用户自定的命令
|:compiler|	:comp[iler]	为特定编译器设定选项
|:continue|	:con[tinue]	回到 :while 开始处
|:confirm|	:conf[irm]	需要确认时，提示用户
|:copen|	:cope[n]	打开 quickfix 窗口
|:cprevious|	:cp[revious]	跳转到上一个错误
|:cpfile|	:cpf[ile]	跳转到上一个文件的最后一个错误
|:cquit|	:cq[uit]	退出 Vim，带错误码
|:crewind|	:cr[ewind]	跳到指定的错误，缺省为第一个
|:cscope|	:cs[cope]       执行 cscope 命令
|:cstag|	:cst[ag]	使用 cscope 来跳转到标签上
|:cunmap|	:cu[nmap]	类似于 ":unmap"，但用于命令行模式
|:cunabbrev|	:cuna[bbrev]	类似于 ":unabbrev"，但用于命令行模式
|:cunmenu|	:cunme[nu]	删除命令行的菜单
|:cwindow|	:cw[indow]	打开或者关闭 quickfix 窗口
|:delete|	:d[elete]	删除行
|:delmarks|	:delm[arks]	删除位置标记
|:debug|	:deb[ug]	在调试模式执行命令
|:debuggreedy|	:debugg[reedy]	从正常的输入那里读取调试模式命令
|:delcommand|	:delc[ommand]	删除用户自定的命令
|:delfunction|	:delf[unction]	删除用户函数
|:diffupdate|	:dif[fupdate]	更新 'diff' 缓冲区
|:diffget|	:diffg[et]	删除当前缓冲区的所有差异
|:diffoff|	:diffo[ff]	关闭 diff 模式
|:diffpatch|	:diffp[atch]	应用补丁然后显示差异
|:diffput|	:diffpu[t]	删除另外一个缓冲区的差异
|:diffsplit|	:diffs[plit]	显示和另外一个文件的差异
|:diffthis|	:diffthis	使得当前窗口成为 diff 窗口
|:digraphs|	:dig[raphs]	显示或者输入二合字母
|:display|	:di[splay]	显示寄存器
|:dl|		:dl		|:delete| 的简写
|:dl|		:del[ete]l	|:delete| 的简写
|:djump|	:dj[ump]	跳转到 #define
|:dlist|	:dli[st]	列出所有的 #define
|:doautocmd|	:do[autocmd]	在当前缓冲区应用自动命令
|:doautoall|	:doautoa[ll]	在所有载入的缓冲区上应用自动命令
|:dp|		:d[elete]p	|:delete| 的简写
|:drop|		:dr[op]		跳到编辑某文件的窗口，不成功则在当前窗口编辑之
|:dsearch|	:ds[earch]	列出一个 #define
|:dsplit|	:dsp[lit]	分割窗口并跳转到 #define
|:edit|		:e[dit]		编辑文件
|:earlier|	:ea[rlier]	回到旧的改变，撤销
|:echo|		:ec[ho]		回显表达式结果
|:echoerr|	:echoe[rr]	类似于 :echo，如同错误一样显示和使用历史
|:echohl|	:echoh[l]	为 echo 等命令设置高亮
|:echomsg|	:echom[sg]	等同于 :echo，在历史里放置消息
|:echon|	:echon		等同于 :echo，但不留 <EOL>
|:else|		:el[se]		:if 命令的一部分
|:elseif|	:elsei[f]	:if 命令的一部分
|:emenu|	:em[enu]	按名字执行菜单
|:endif|	:en[dif]	结束最近的 :if
|:endfor|	:endfo[r]	结束最近的 :for
|:endfunction|	:endf[unction]	结束用户函数
|:endtry|	:endt[ry]	结束最近的 :try
|:endwhile|	:endw[hile]	结束最近的 :while
|:enew|		:ene[w]		编辑新的无名缓冲区
|:ex|		:ex		等同于 ":edit"
|:execute|	:exe[cute]	执行表达式的结果产生的字符串
|:exit|		:exi[t]		等同于 ":xit"
|:exusage|	:exu[sage]	Ex 命令总览
|:file|		:f[ile]		显示或者设置当前文件名
|:files|	:files		列出缓冲区列表的所有文件
|:filetype|	:filet[ype]	切换文件类型检测的打开/关闭
|:find|		:fin[d]		在 'path' 里找寻文件并编辑之
|:finally|	:fina[lly]	:try 命令的一部分
|:finish|	:fini[sh]	退出 Vim 脚本的执行
|:first|	:fir[st]	转到参数列表的第一个文件
|:fixdel|	:fix[del]	设置 <Del> 的键码
|:fold|		:fo[ld]		创建折叠
|:foldclose|	:foldc[lose]	关闭折叠
|:folddoopen|	:foldd[oopen]	对所有不在关闭折叠的行执行命令
|:folddoclosed|	:folddoc[losed]	对所有在关闭折叠的行执行命令
|:foldopen|	:foldo[pen]	打开折叠
|:for|		:for		for 循环
|:function|	:fu[nction]	定义用户函数
|:global|	:g[lobal]	对匹配的行执行命令
|:goto|		:go[to]		转到缓冲区某字节处
|:grep|		:gr[ep]		执行 'grepprg' 并转到第一个匹配处
|:grepadd|	:grepa[dd]	类似 :grep，但附加到当前列表后
|:gui|		:gu[i]		启动 GUI
|:gvim|		:gv[im]		启动 GUI
|:hardcopy|	:ha[rdcopy]	发送文本到打印机
|:help|		:h[elp]		打开帮助窗口
|:helpfind|	:helpf[ind]	打开显示帮助窗口的对话框
|:helpgrep|	:helpg[rep]	类似于 ":grep"，但搜索帮助文件
|:helptags|	:helpt[ags]	为一个目录产生帮助标签
|:highlight|	:hi[ghlight]	指定高亮方法
|:hide|		:hid[e]		为一个命令隐藏当前缓冲区
|:history|	:his[tory]	显示历史列表
|:insert|	:i[nsert]	插入文本
|:iabbrev|	:ia[bbrev]	类似于 ":abbrev"，但用于插入模式
|:iabclear|	:iabc[lear]	类似于 ":abclear"，但用于插入模式
|:if|		:if		条件满足时执行命令
|:ijump|	:ij[ump]	跳转到标识符的定义
|:ilist|	:il[ist]	列出匹配标识符的行
|:imap|		:im[ap]		类似于 ":map"，但用于插入模式
|:imapclear|	:imapc[lear]	类似于 ":map"，但用于插入模式
|:imenu|	:ime[nu]	为插入模式增加菜单
|:inoremap|	:ino[remap]	类似于 ":noremap"，但用于插入模式
|:inoreabbrev|	:inorea[bbrev]	类似于 ":noreabbrev"，但用于插入模式
|:inoremenu|	:inoreme[nu]	类似于 ":noremenu"，但用于插入模式
|:intro|	:int[ro]	显示介绍文字
|:isearch|	:is[earch]	列出匹配标识符的一行
|:isplit|	:isp[lit]	分割窗口，并跳转到标识符的定义
|:iunmap|	:iu[nmap]	类似于 ":unmap"，但用于插入模式
|:iunabbrev|	:iuna[bbrev]	类似于 ":unabbrev"，但用于插入模式
|:iunmenu|	:iunme[nu]	删除插入模式的菜单
|:join|		:j[oin]		连接行
|:jumps|	:ju[mps]	显示跳转表
|:k|		:k		设置位置标记
|:keepalt|	:keepa[lt]	跟随的命令保持轮换文件不变
|:keepmarks|	:kee[pmarks]	跟随的命令保持位置标记不变
|:keepjumps|	:keepj[umps]	跟随的命令保持跳转表和位置标记不变
|:lNext|	:lN[ext]	转到位置列表的上一个位置
|:lNfile|	:lNf[ile]	转到上个文件的最近一个位置
|:list|		:l[ist]		显示行
|:laddexpr|	:lad[dexpr]	通过表达式补充位置
|:laddbuffer|	:laddb[uffer]	通过缓冲区补充位置
|:laddfile|	:laddf[ile]	把位置加到当前位置列表里
|:last|		:la[st]		转到参数列表的最后一个文件
|:language|	:lan[guage]	设置语言 (locale)
|:later|	:lat[er]	转到新的改变，重做
|:lbuffer|	:lb[uffer]	分析位置并跳转到第一个位置
|:lcd|		:lc[d]		改变本地的目录
|:lchdir|	:lch[dir]	改变本地的目录
|:lclose|	:lcl[ose]	关闭位置窗口
|:lcscope|	:lcs[cope]      类似于 ":cscope"，但使用位置列表
|:left|		:le[ft]		左对齐行
|:leftabove|	:lefta[bove]	使得分割的窗口出现在左侧或者上方
|:let|		:let		给变量或选项赋值
|:lexpr|	:lex[pr]	从表达式里读取位置并跳转到第一个
|:lfile|	:lf[ile]	从文件里读取位置并跳转到第一个
|:lfirst|	:lfir[st]	转到指定的位置上，缺省第一个
|:lgetbuffer|	:lgetb[uffer]	从缓冲区里读取位置
|:lgetexpr|	:lgete[xpr]	从表达式里读取位置
|:lgetfile|	:lg[etfile]	从文件里读取位置
|:lgrep|	:lgr[ep]	运行 'grepprg' 并跳转到第一个匹配
|:lgrepadd|	:lgrepa[dd]	类似于 :grep，但附加到当前列表上
|:lhelpgrep|	:lh[elpgrep]	类似于 ":helpgrep"，但使用位置列表
|:ll|		:ll		转到指定位置
|:llast|	:lla[st]	转到指定位置，缺省最后一个
|:llist|	:lli[st]	列出所有的位置
|:lmake|	:lmak[e]	执行外部命令 'makeprg' 并分析错误信息
|:lmap|		:lm[ap]		类似于 ":map!"，但包括 Lang-Arg 模式
|:lmapclear|	:lmapc[lear]	类似于 ":mapclear!"，但包括 Lang-Arg 模式
|:lnext|	:lne[xt]	跳到下一个位置
|:lnewer|	:lnew[er]	跳到较新的位置列表
|:lnfile|	:lnf[ile]	跳到下一个文件的第一个位置
|:lnoremap|	:ln[oremap]	类似于 ":noremap!"，但包括 Lang-Arg 模式
|:loadkeymap|	:loadk[eymap]	载入后面的键盘映射表，直到 EOF 为止
|:loadview|	:lo[adview]	从文件里为当前窗口载入视图
|:lockmarks|	:loc[kmarks]	跟随的命令保持位置标记不变
|:lockvar|	:lockv[ar]	给变量加锁
|:lolder|	:lol[der]	转到较旧的位置列表
|:lopen|	:lope[n]	打开位置窗口
|:lprevious|	:lp[revious]	转到前一个位置
|:lpfile|	:lpf[ile]	转到上一个文件的最近的位置
|:lrewind|	:lr[ewind]	转到指定的位置，缺省第一个
|:ls|		:ls		列出所有的缓冲区
|:ltag|		:lt[ag]		跳转到标签，并把匹配的标签加到位置列表上
|:lunmap|	:lu[nmap]	类似于 ":unmap!"，但包括 Lang-Arg 模式
|:lua|		:lua		执行 |Lua| 命令
|:luado|	:luad[o]	对每行都执行 Lua 命令
|:luafile|	:luaf[ile]	执行 |Lua| 脚本文件
|:lvimgrep|	:lv[imgrep]	在若干文件里搜索模式
|:lvimgrepadd|	:lvimgrepa[dd]	类似于 :vimgrep，但附加到当前列表
|:lwindow|	:lw[indow]	打开或关闭位置窗口
|:move|		:m[ove]		移动行
|:mark|		:ma[rk]		设置位置标记
|:make|		:mak[e]		执行外部命令 'makeprg' 并分析其错误信息
|:map|		:map		显示或者输入映射
|:mapclear|	:mapc[lear]	清除所有普通和可视模式的映射
|:marks|	:marks		列出所有的位置标记
|:match|	:mat[ch]	定义要高亮显示的匹配的模式
|:menu|		:me[nu]		输入新的菜单项
|:menutranslate| :menut[ranslate] 增加菜单翻译项目
|:messages|	:mes[sages]	显示以前显示的消息
|:mkexrc|	:mk[exrc]	写入当前映射和设置到文件
|:mksession|	:mks[ession]	写入会话信息到文件
|:mkspell|	:mksp[ell]	生成 .spl 拼写文件
|:mkvimrc|	:mkv[imrc]	写入当前映射和设置到文件
|:mkview|	:mkvie[w]	写入当前窗口的视图到文件
|:mode|		:mod[e]		显示或者改变屏幕模式
|:mzscheme|	:mz[scheme]	执行 MzScheme 命令
|:mzfile|	:mzf[ile]	执行 MzScheme 脚本文件
|:nbclose|	:nbc[lose]	关闭当前 Netbeans 会话
|:nbkey|	:nb[key]	传递一个键给 Netbeans
|:nbstart|	:nbs[art]	打开一个新的 Netbeans 会话
|:next|		:n[ext]		跳转到参数列表的下一个文件
|:new|		:new		创建一个新的空白窗口
|:nmap|		:nm[ap]		类似于 ":map"，但使用普通模式
|:nmapclear|	:nmapc[lear]	清除普通模式的所有映射
|:nmenu|	:nme[nu]	为普通模式增加菜单
|:nnoremap|	:nn[oremap]	类似于 ":noremap"，但使用普通模式
|:nnoremenu|	:nnoreme[nu]	类似于 ":noremenu"，但使用普通模式
|:noautocmd|	:noa[utocmd]	跟随的命令不激活自动命令
|:noremap|	:no[remap]	输入不会被重新映射的映射
|:nohlsearch|	:noh[lsearch]	暂停 'hlsearch' 高亮
|:noreabbrev|	:norea[bbrev]	输入不会被重新映射的缩写
|:noremenu|	:noreme[nu]	输入不会被重新映射的菜单
|:normal|	:norm[al]	执行普通模式的命令
|:number|	:nu[mber]	显示文本行时给出行号
|:nunmap|	:nun[map]	类似于 ":unmap"，但使用普通模式
|:nunmenu|	:nunme[nu]	删除普通模式的菜单
|:oldfiles|	:ol[dfiles]	列出 viminfo 文件中包含位置标记的文件
|:open|		:o[pen]		启动打开模式 (没有实现)
|:omap|		:om[ap]		类似于 ":map"，但使用操作符等待模式
|:omapclear|	:omapc[lear]	删除操作符等待模式的所有映射
|:omenu|	:ome[nu]	为操作符等待模式增加菜单
|:only|		:on[ly]		关闭当前窗口，除了当前的窗口以外
|:onoremap|	:ono[remap]	类似于 ":noremap"，但使用操作符等待模式
|:onoremenu|	:onoreme[nu]	类似于 ":noremenu"，但使用操作符等待模式
|:options|	:opt[ions]	打开选项窗口
|:ounmap|	:ou[nmap]	类似于 ":unmap"，但使用操作符等待模式
|:ounmenu|	:ounme[nu]	删除操作符等待模式的菜单
|:ownsyntax|	:ow[nsyntax]	为本窗口设置新的局部语法高亮
|:print|	:p[rint]	显示行
|:profdel|	:profd[el]	停止剖视 (profile) 函数或脚本
|:profile|	:prof[ile]	剖视 (profile) 函数或脚本
|:promptfind|	:pro[mptfind]	打开 GUI 对话框进行搜索
|:promptrepl|	:promptr[epl]	打开 GUI 对话框进行搜索/替代
|:pclose|	:pc[lose]	关闭预览窗口
|:pedit|	:ped[it]	在预览窗口编辑文件
|:perl|		:pe[rl]		执行 Perl 命令
|:perldo|	:perld[o]	对每行都执行 Perl 命令
|:pop|		:po[p]		跳转到标签栈较旧的项目上
|:popup|	:popu[p]	根据名字弹出菜单
|:ppop|		:pp[op]		在预览窗口 ":pop"
|:preserve|	:pre[serve]	写入所有文本到交换文件
|:previous|	:prev[ious]	跳转到参数列表里的上一个文件
|:psearch|	:ps[earch]	类似于 ":ijump"，但在预览窗口显示匹配
|:ptag|		:pt[ag]		在预览窗口显示标签
|:ptNext|	:ptN[ext]	在预览窗口 |:tNext|
|:ptfirst|	:ptf[irst]	在预览窗口 |:trewind|
|:ptjump|	:ptj[ump]	在预览窗口 |:tjump| 和显示标签
|:ptlast|	:ptl[ast]	在预览窗口 |:tlast|
|:ptnext|	:ptn[ext]	在预览窗口 |:tnext|
|:ptprevious|	:ptp[revious]	在预览窗口 |:tprevious|
|:ptrewind|	:ptr[ewind]	在预览窗口 |:trewind|
|:ptselect|	:pts[elect]	在预览窗口 |:tselect| 和显示标签
|:put|		:pu[t]		插入寄存器的内容到文本
|:pwd|		:pw[d]		显示当前目录
|:py3|		:py3		执行 Python 3 命令
|:python3|	:python3	同 :py3
|:py3do|	:py3d[o]	对每行都执行 Python 3 命令
|:py3file|	:py3f[ile]	执行 Python 3 脚本文件
|:python|	:py[thon]	执行 Python 命令
|:pydo|		:pyd[o]		对每行都执行 Python 命令
|:pyfile|	:pyf[ile]	执行 Python 脚本文件
|:quit|		:q[uit]		退出当前窗口 (如果只有一窗口，则退出 Vim)
|:quitall|	:quita[ll]	退出 Vim
|:qall|		:qa[ll]		退出 Vim
|:read|		:r[ead]		读入文件到文本
|:recover|	:rec[over]	从交换文件里恢复文件
|:redo|		:red[o]		重做一次撤销的改变
|:redir|	:redi[r]	重定向消息到文件或者寄存器
|:redraw|	:redr[aw]	强迫显示的重画
|:redrawstatus|	:redraws[tatus]	强迫状态行的重画
|:registers|	:reg[isters]	显示寄存器的内容
|:resize|	:res[ize]	改变当前窗口的高度
|:retab|	:ret[ab]	改变制表大小
|:return|	:retu[rn]	从用户函数返回
|:rewind|	:rew[ind]	转到参数列表的第一个文件
|:right|	:ri[ght]	右对齐文本
|:rightbelow|	:rightb[elow]	使得分割窗口出现在右侧或者下方
|:ruby|		:rub[y]		执行 Ruby 命令
|:rubydo|	:rubyd[o]	对每行执行 Ruby 命令
|:rubyfile|	:rubyf[ile]	执行 Ruby 脚本文件
|:rundo|	:rund[o]	从文件里读入撤销信息
|:runtime|	:ru[ntime]	执行 'runtimepath' 里的 vim 脚本
|:rviminfo|	:rv[iminfo]	读取 viminfo 文件
|:substitute|	:s[ubstitute]	查找和替代文本
|:sNext|	:sN[ext]	分割窗口并转到参数列表的前一个文件
|:sandbox|	:san[dbox]	在沙盘里执行命令
|:sargument|	:sa[rgument]	分割窗口并转到参数列表的某一个文件
|:sall|		:sal[l]		为参数列表的每个文件打开窗口
|:saveas|	:sav[eas]	用别的名字保存文件。
|:sbuffer|	:sb[uffer]	分割窗口并转到缓冲区列表的某一个文件
|:sbNext|	:sbN[ext]	分割窗口并转到缓冲区列表的前一个文件
|:sball|	:sba[ll]	为缓冲区列表的每个文件打开窗口
|:sbfirst|	:sbf[irst]	分割窗口并转到缓冲区列表的第一个文件
|:sblast|	:sbl[ast]	分割窗口并转到缓冲区列表的最后一个文件
|:sbmodified|	:sbm[odified]	分割窗口并转到缓冲区列表的修改过的文件
|:sbnext|	:sbn[ext]	分割窗口并转到缓冲区列表的后一个文件
|:sbprevious|	:sbp[revious]	分割窗口并转到缓冲区列表的前一个文件
|:sbrewind|	:sbr[ewind]	分割窗口并转到缓冲区列表的第一个文件
|:scriptnames|	:scrip[tnames]	列出所有执行过的 Vim 脚本的名字
|:scriptencoding| :scripte[ncoding]	执行过的 Vim 脚本使用的编码
|:scscope|	:scs[cope]	分割窗口并执行 cscope 命令
|:set|		:se[t]		显示或设置选项
|:setfiletype|	:setf[iletype]	设置 'filetype'，除非已经设置过
|:setglobal|	:setg[lobal]	显示或者设置全局选项值
|:setlocal|	:setl[ocal]	显示或者设置本地选项值
|:sfind|	:sf[ind]	分割当前窗口并编辑 'path' 的文件
|:sfirst|	:sfir[st]	分割窗口并转到参数列表的第一个文件
|:shell|	:sh[ell]	退到外壳程序
|:simalt|	:sim[alt]	Win32 GUI: 模拟 Windows ALT 键
|:sign|		:sig[n]		操作标号
|:silent|	:sil[ent]	安静地运行命令
|:sleep|	:sl[eep]	几秒内不作任何事
|:slast|	:sla[st]	分割窗口并转到参数列表的最后一个文件
|:smagic|	:sm[agic]	带 'magic' 的 :substitute
|:smap|		:smap		类似于 ":map"，但用于选择模式
|:smapclear|	:smapc[lear]	删除选择模式所有的映射
|:smenu|	:sme[nu]	增加选择模式菜单
|:snext|	:sn[ext]	分割窗口并转到参数列表的下一个文件
|:sniff|	:sni[ff]	发送请求到 sniff
|:snomagic|	:sno[magic]	带 'nomagic' 的 :substitute
|:snoremap|	:snor[emap]	类似于 ":noremap"，但用于选择模式
|:snoremenu|	:snoreme[nu]	类似于 ":noremenu"，但用于选择模式
|:sort|		:sor[t]		给行排序
|:source|	:so[urce]	从文件里读取 Vim 或 Ex 命令
|:spelldump|	:spelld[ump]	分割窗口并用正确的单词填充
|:spellgood|	:spe[llgood]	增加拼写的好词
|:spellinfo|	:spelli[nfo]	显示载入的拼写文件的信息
|:spellrepall|	:spellr[epall]	像上次 |z=| 那样，但替换所有的坏词
|:spellundo|	:spellu[ndo]	删除好词或坏词
|:spellwrong|	:spellw[rong]	增加拼写错误
|:split|	:sp[lit]	分割当前窗口
|:sprevious|	:spr[evious]	分割窗口并转到参数列表的前一个文件
|:srewind|	:sre[wind]	分割窗口并转到参数列表的第一个文件
|:stop|		:st[op]		暂停编辑器并退回外壳
|:stag|		:sta[g]		分割窗口并跳转到标签上
|:startgreplace| :startg[replace] 开始虚拟替换模式
|:startreplace|	:startr[eplace]	开始替换模式
|:startinsert|	:star[tinsert]	开始插入模式
|:stopinsert|	:stopi[nsert]	退出插入模式
|:stjump|	:stj[ump]	执行 ":tjump" 并分割窗口
|:stselect|	:sts[elect]	执行 ":tselect" 并分割窗口
|:sunhide|	:sun[hide]	等同于 ":unhide"
|:sunmap|	:sunm[ap]	类似于 ":unmap"，但用于选择模式
|:sunmenu|	:sunme[nu]	删除选择模式的菜单
|:suspend|	:sus[pend]	等同于 ":stop"
|:sview|	:sv[iew]	分割窗口并以只读模式编辑文件
|:swapname|	:sw[apname]	显示当前交换文件的名字
|:syntax|	:sy[ntax]	语法高亮
|:syntime|	:synti[me]	测量语法高亮速度
|:syncbind|	:sync[bind]	同步滚动绑定
|:t|		:t		等同于 ":copy"
|:tNext|	:tN[ext]	跳转到上一个匹配的标签
|:tabNext|	:tabN[ext]	跳到上一个标签页
|:tabclose|	:tabc[lose]	关闭当前标签页
|:tabdo|	:tabdo		为每个标签页执行命令
|:tabedit|	:tabe[dit]	在新标签页里编辑文件
|:tabfind|	:tabf[ind]	寻找 'path' 里的文件，在新标签页里编辑之
|:tabfirst|	:tabfir[st]	转到第一个标签页
|:tablast|	:tabl[ast]	转到最后一个标签页
|:tabmove|	:tabm[ove]	把标签页移到别的位置
|:tabnew|	:tabnew		在新标签页里编辑文件
|:tabnext|	:tabn[ext]	转到下一个标签页
|:tabonly|	:tabo[nly]	关闭所有除了当前标签页以外的所有标签页
|:tabprevious|	:tabp[revious]	转到前一个标签页
|:tabrewind|	:tabr[ewind]	转到第一个标签页
|:tabs|		:tabs		列出标签页以及里面包含的内容
|:tab|		:tab		打开新窗口时建立新的标签页
|:tag|		:ta[g]		跳转到标签上
|:tags|		:tags		显示标签栈的内容
|:tcl|		:tc[l]		执行 Tcl 命令
|:tcldo|	:tcld[o]	为每行执行 Tcl 命令
|:tclfile|	:tclf[ile]	执行 Tcl 脚本文件
|:tearoff|	:te[aroff]	撕下一个菜单
|:tfirst|	:tf[irst]	转到第一个匹配的标签
|:throw|	:th[row]	抛出例外
|:tjump|	:tj[ump]	类似于 ":tselect"，只有一个匹配时直接跳转之
|:tlast|	:tl[ast]	跳转到最后一个匹配的标签
|:tmenu|	:tm[enu]	定义菜单的工具提示
|:tnext|	:tn[ext]	跳转到下一个匹配的标签
|:topleft|	:to[pleft]	使得分割的窗口出现在顶部或者最左端
|:tprevious|	:tp[revious]	跳转到上一个匹配的标签
|:trewind|	:tr[ewind]	跳转到第一个匹配的标签
|:try|		:try		执行命令，错误或者例外时终止
|:tselect|	:ts[elect]	列出匹配的标签并从中选择一个
|:tunmenu|	:tu[nmenu]	删除菜单的工具提示
|:undo|		:u[ndo]		撤销最近的改变
|:undojoin|	:undoj[oin]	将下一个改变和上一个撤销块合并
|:undolist|	:undol[ist]	列出撤销树的叶结点
|:unabbreviate|	:una[bbreviate]	删除缩写
|:unhide|	:unh[ide]	为缓冲区列表里每个载入的文件打开窗口
|:unlet|	:unl[et]	删除变量
|:unlockvar|	:unlo[ckvar]	给变量解锁
|:unmap|	:unm[ap]	删除映射
|:unmenu|	:unme[nu]	删除菜单
|:unsilent|	:uns[ilent]	非安静模式执行命令
|:update|	:up[date]	如果有修改，写回缓冲区
|:vglobal|	:v[global]	对不匹配的行，执行命令
|:version|	:ve[rsion]	显示版本号和其它信息
|:verbose|	:verb[ose]	执行命令，过程中设置 'verbose'
|:vertical|	:vert[ical]	使得跟随的命令垂直分割
|:vimgrep|	:vim[grep]	在若干文件里查找模式
|:vimgrepadd|	:vimgrepa[dd]	类似于 :vimgrep，但附加到当前列表
|:visual|	:vi[sual]	等同于 ":edit"，但关掉 "Ex" 模式
|:viusage|	:viu[sage]	普通模式命令的总览
|:view|		:vie[w]		以只读方式编辑文件
|:vmap|		:vm[ap]		类似于 ":map"，但使用可视+选择模式
|:vmapclear|	:vmapc[lear]	删除可视+选择模式所有的映射
|:vmenu|	:vme[nu]	为可视+选择模式增加菜单
|:vnew|		:vne[w]		建立新的空白窗口，垂直分割
|:vnoremap|	:vn[oremap]	类似于 ":noremap"，但使用可视+选择模式
|:vnoremenu|	:vnoreme[nu]	类似于 ":noremenu"，但使用可视+选择模式
|:vsplit|	:vs[plit]	垂直分割当前窗口
|:vunmap|	:vu[nmap]	类似于 ":unmap"，但使用可视+选择模式
|:vunmenu|	:vunme[nu]	删除可视+选择模式的菜单
|:windo|	:windo		为每个窗口执行命令
|:write|	:w[rite]	写回文件
|:wNext|	:wN[ext]	写回文件，然后跳转到参数列表的前一个文件
|:wall|		:wa[ll]		写回所有 (改变的) 缓冲区
|:while|	:wh[ile]	只要条件满足，执行循环体
|:winsize|	:wi[nsize]	取得或者设置窗口大小 (已废弃)
|:wincmd|	:winc[md]	执行窗口 (CTRL-W) 命令
|:winpos|	:winp[os]	取得或者设置窗口位置
|:wnext|	:wn[ext]	写回文件，然后跳转到参数列表的下一个文件
|:wprevious|	:wp[revious]	写回文件，然后跳转到参数列表的前一个文件
|:wq|		:wq		写回文件，然后退出窗口或者 Vim
|:wqall|	:wqa[ll]	写回所有 (改变的) 缓冲区然后退出 Vim
|:wsverb|	:ws[verb]	把动词通过 IPC 发送给 workshop
|:wundo|	:wu[ndo]	把撤销信息写入文件
|:wviminfo|	:wv[iminfo]	写入 viminfo 文件
|:xit|		:x[it]		如果缓冲区被改动，写入之。然后退出窗口或者 Vim
|:xall|		:xa[ll]		等同于 ":wqall"
|:xmapclear|	:xmapc[lear]	删除可视模式的所有映射
|:xmap|		:xm[ap]		类似于 ":map"，但使用可视模式
|:xmenu|	:xme[nu]	增加可视模式的菜单
|:xnoremap|	:xn[oremap]	类似于 ":noremap"，但使用可视模式
|:xnoremenu|	:xnoreme[nu]	类似于 ":noremenu"，但使用可视模式
|:xunmap|	:xu[nmap]	类似于 ":unmap"，但使用可视模式
|:xunmenu|	:xunme[nu]	删除可视模式的菜单
|:yank|		:y[ank]		抽出行到寄存器
|:z|		:z		显示一些行
|:~|		:~		重复上次 ":substitute"


 vim:tw=78:ts=8:ft=help:norl:
