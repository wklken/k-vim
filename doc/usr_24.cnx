*usr_24.txt*	For Vim version 7.4.	最近更新: 2006年12月

		     VIM 用户手册 - Bram Moolenaar 著
		  译者:  Chimin Yen，tocer http://vimcdoc.sf.net

			      快速插入


输入文本时，Vim 提供你各种各样的方法来减少键击次数和避免打字错误。你可以利用插
入模式下的补全功能来重复先前打过的单词。也可以把长词缩写成短词。甚至可以打出你
键盘上没有的字符。

|24.1|	更正
|24.2|	显示匹配
|24.3|	补全
|24.4|	重复一次插入
|24.5|	从另一行拷贝
|24.6|	插入一个寄存器内容
|24.7|	缩写
|24.8|	插入特殊字符
|24.9|	二合字母
|24.10|	普通模式命令

       下一章: |usr_25.txt|  编辑带格式的文本
       前一章: |usr_23.txt|  编辑特殊文件
         目录: |usr_toc.txt|

==============================================================================
*24.1*	更正

退格键 <BS> 已经在前面提过了。它删除位于光标前一格的字符。而删除键 <Del> 则删
除光标下 (或者说光标后也可以) 的那个字符。
   当你把整个词都打错了的时候，用 CTRL-W 来更正:

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

如果你把一行字弄得不可收拾，而要从头来过的话，用 CTRL-U 来删除。这个命令保留了
光标之后的文本，也保留了行首的缩进。它只删除了自第一个非空字符至光标位置之间的
文本。让光标位于下一行中 "fallen" 的 "f" 上，按 CTRL-U，文本就成了这样:

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

当你发现几个词之前有个错误，你需要把光标移到那儿作更正。例如，你打了这样一行:

	The horse had follen to the ground ~

你要把 "follen" 改成 "fallen"。让光标留在行尾，你输入这个字符串就能更正那错
误: >

					<Esc>4blraA

<	脱离插入模式			<Esc>
	退回 4 个单词			     4b
	移到字母 "o" 上 		       l
	以字母 "a" 替代 			ra
	重新开始插入模式    			  A

另一种更正这个错误的方法: >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	退回 4 个词		     <C-Left><C-Left><C-Left><C-Left>
	移到字母 "o" 上 			<Right>
	删除字母 "o"				       <Del>
	插入字母 "a"					    a
	移到行尾        				     <End>

这种方法让你留在插入模式下，利用特殊键来移动光标。这类似于你在一个不分模式的编
辑器里所采用的操作方法。它比较容易记忆，但比较费事 (你必须把你的手从字母键移动
到光标方向键，而且，不看键盘难以按准 <End> 键)。
   这些特殊键在书写一个停留在插入模式下的映射时非常有用。额外所需的键盘录入也
是值得的。
   你在插入模式下可以利用的特殊键有以下这些:

	<C-Home>	移到文件首
	<PageUp>	上卷一屏
	<Home>		移到行首
	<S-Left>	左移一个单词
	<C-Left>	左移一个单词
	<S-Right>	右移一个单词
	<C-Right>	右移一个单词
	<End>		移到行尾
	<PageDown>	下卷一屏
	<C-End>		移到文件尾

还有很多键，参见 |ins-special-special|。

==============================================================================
*24.2*	显示匹配

你键入一个右括号 ) 时，如果能知道它匹配哪个左括号 ( 会很方便。要让 Vim 做到这
点，用下面这个命令: >

	:set showmatch

现在你键入比如 "(example)" 这样几个字，当你键入右括号 ) 时，Vim 就把光标闪到匹
配的左括号 ( 上，在那儿停留半秒钟，然后返回原处。
   如果匹配的左括号不存在，Vim 就鸣起响铃。这样你就会想起来你可能在哪儿忘了一
个左括号，或键入了太多次的右括号。
   Vim 也会为 [] 和 {} 这样的括号显示匹配。你不必等待光标返回原处才键入下一个
字符，只要下一个字符一键入，光标就会返回，而插入就会跟以前一样继续。
   你可以用 'matchtime' 选项改变 Vim 在匹配括号上停留的时间。例如，要让 Vim 等
待 1.5 秒: >

	:set matchtime=15

指定的时间以 1/10 秒为单位。

==============================================================================
*24.3*	补全

Vim 能自动补全插入的单词。你键入一个单词的开头部分，按 CTRL-P，Vim 就会为你猜
测余下的部分。
   例如，假定你正在建立一个 C 程序，并要键入以下语句:

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

你先输入下面这部分:

	total = ch_array[0] + ch_ ~

此时，你用命令 CTRL-P 告诉 Vim 来补全这个词。Vim 就会搜索以光标前字符串开头的
词。在这个例子中，就是 "ch_"，与词 ch_array 匹配。所以，键入 CTRL-P 就会得到下
面的结果:

	total = ch_array[0] + ch_array ~

再键入几个字符使这个语句变成这样 (结尾是空格):

	total = ch_array[0] + ch_array[1] +  ~

如果你现在键入 CTRL-P，Vim 将再次搜索以补全光标前的词。由于光标前是空格，它找
到的是之前的第一个词，即 "ch_array"。再键入 CTRL-P 给你下一个匹配的词，在本例
中就是 "total"。第三次 CTRL-P 搜寻更前面的。如果那儿没其它的了，编辑器就会陷入
无词可配状态，所以搜索就返回原处，即那个空格。第四次 CTRL-P 导致编辑器周而复
始，又找到 "ch_array"。

往下搜索，用 CTRL-N。由于在文件结尾搜索又绕回开头，CTRL-N 和 CTRL-P 将找到相同
的匹配，但顺序不同。提示: CTRL-N 意为下一个匹配，而 CTRL-P 意为前一个匹配。
(译者: 英文 Next 意为下一个，Previous 意为前一个)

Vim 编辑器会非常努力的来补全不完整的词。默认情况下，它搜索如下一些地方:

	1.当前文件
	2.其它窗口内的文件
	3.其它载入文件 (隐藏缓冲区)
	4.未载入文件 (非激活缓冲区)
	5.标签文件
	6.被当前文件以 #include 语句包含的所有头文件


选 项

你可以利用 'complete' 选项定制搜索顺序。

还可以使用 'ignorecase' 选项。设定这个选项后，搜寻匹配时大小写的区别就会被忽
略。

一个特殊的补全选项是 'infercase'。它的用处是在寻找忽略大小写的匹配时
('ignorecase' 必须先被设定)，但仍然采用已键入部分的大小写。这样，如果你键入
"For" 而 Vim 找到了匹配 "fortunately"，所产生的结果将是 "Fortunately"。


补 全 特 定 文 本

如果你知道你要找什么，那么你可以用这些命令来补全某种类型的文本:

	CTRL-X CTRL-F		文件名
	CTRL-X CTRL-L		整行
	CTRL-X CTRL-D		宏定义 (包括包含文件里的)
	CTRL-X CTRL-I		当前文件以及所包含的文件
	CTRL-X CTRL-K		字典文件内的单词
	CTRL-X CTRL-T		同义词词典文件内的单词
	CTRL-X CTRL-]		标签
	CTRL-X CTRL-V		Vim 命令行

每个命令之后，CTRL-N 可以用来搜索下一个匹配，而 CTRL-P 则用于搜索前一个匹配。
   关于每个命令的详细用法，参见: |ins-completion|。


补 全 文 件 名

我们以 CTRL-X CTRL-F 为例。这个命令将找寻文件名。它在当前目录里搜索文件，并显
示每一个与光标前单词匹配的文件名。
   例如，假定你在当前目录里有下面这些文件:

	main.c  sub_count.c  sub_done.c  sub_exit.c

现在进入插入模式并开始键入:

	The exit code is in the file sub ~

就在这点上，你输入 CTRL-X CTRL-F。现在，Vim 通过查看当前目录里的文件来补全当前
词 "sub"。最初的匹配是 sub_count.c。这不是你想要的，所以你按 CTRL-N 以匹配下一
个文件。这次匹配的是 sub_done.c。再键入 CTRL-N 给了你 sub_exit.c。结果:

	The exit code is in the file sub_exit.c ~

如果文件名以 / (Unix) 或 C:\ (MS-Windows) 开头，那么你就能搜索文件系统下所有的
文件。例如，键入 "/u" 然后 CTRL-X CTRL-F，这将匹配 "/usr" (这是在 Unix 上):

	the file is found in /usr/ ~

如果你现在按 CTRL-N，你就又回到 "/u"。接受 "/usr/" 并进入下一层目录，再来一次
CTRL-X CTRL-F:

	the file is found in /usr/X11R6/ ~

当然，匹配结果取决于你的文件系统上有什么文件。匹配结果以字母顺序来排列。


补 全 源 代 码

源代码文件有良好的结构。这使通过某种智能方式补全成为可能。在 Vim 中，这被称为
全能补全。在其他编辑器中，它被称为智能补全(intellisense)，但这是一个注册商标。

全能补全的热键是 CTRL-X CTRL-O。显然，O 在这里代表全能 (Omni)，这样方便我们记
忆。让我们以编辑 C 程序为例: >

	{ ~
	    struct foo *p; ~
	    p-> ~

光标在 "p->" 之后。现在键入 CTRL-X CTRL-O。Vim 会给你提供一个可选项的列表，这
些可选项为 "struct foo" 所拥有。这和使用 CTRL-P 有很大不同，后者补全任意单词，
而我们这里只要求 "struct foo" 的成员。

为使全能补全工作，需要做一些初始化。起码，要保证打开文件类型插件。你的 vimrc
文件应该包含形如: >
	filetype plugin on
或: >
	filetype plugin indent on
的一行。

对于 C 代码，需要建立标签文件并设置 'tags' 选项。在 |ft-c-omni| 中有进一步的解
释。对于其他文件类型，需要做类似的事情，请查看 |compl-omni-filetypes|。补全只
对特定文件类型有效。查看 'omnifunc' 选项的值，以便检查补全能否正常工作。

==============================================================================
*24.4*	重复一次插入

如果你按 CTRL-A，编辑器就把你上次在插入模式下输入的文本再输入一次。
   比如，假定你有个文件，开头是这样的:

	"file.h" ~
	/* Main program begins */ ~

你在第一行开始处插入 "#include ":

	#include "file.h" ~
	/* Main program begins */ ~

你再用命令 "j^" 往下来到下一行的开始处。现在你开始插入一个新的 "#include" 行。
所以你键入: >

	i CTRL-A

结果就像下面这样:

	#include "file.h" ~
	#include /* Main program begins */ ~

"#include " 被插入是因为 CTRL-A 会插入上次插入过的文本。现在你键入 "main.h"
<Enter> 以结束这一行:


	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~

CTRL-@ 命令会完成 CTRL-A 的操作后退出插入模式。这是一个快速重复插入一模一样的
文本的一个方法。

==============================================================================
*24.5*	从另一行拷贝

CTRL-Y 命令插入光标上方的字符。当你复制前一行文本的时候，这个命令很有用。例
如，你有这么一行 C 代码:

	b_array[i]->s_next = a_array[i]->s_next; ~

现在你需要把这一行再键入一次，并以 "s_prev" 取代 "s_next"。换行以后，按 14 次
CTRL-Y，直到光标位于 "next" 的 "n" 上:

	b_array[i]->s_next = a_array[i]->s_next;~
	b_array[i]->s_ ~

现在你键入 "prev":

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

继续按 CTRL-Y 直到下一个 "next":

	b_array[i]->s_next = a_array[i]->s_next;~
	b_array[i]->s_prev = a_array[i]->s_ ~

现在键入 "prev;" 以结束这一行。

CTRL-E 命令操作起来跟 CTRL-Y 一样，只不过它插入光标下方的字符。

==============================================================================
*24.6*	插入一个寄存器内容

命令 CTRL-R {register} 插入寄存器里的内容。它的用处是让你不必键入长词。例如，
你要输入下面这些:

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

这个函数的定义见于另一个文件。编辑那个文件并把光标移到该函数名上，然后把文件名
摄入寄存器 v: >

	"vyiw

"v 指定寄存器，"yiw" 意思是拷贝一个词，不含空格 (yank-inner-word)。现在编辑那
个要插入一行代码的文件，先键入开头几个字符:

	r = ~

现在用 CTRL-R v 来插入函数名:

	r = VeryLongFunction ~

你接下来在函数名后面键入其它必要字符，然后再用两次 CTRL-R v。
   你也可以用补全功能来完成同样的工作。但当你有好几个词，其开头几个字符都一样
的时候，寄存器就有用多了。

如果寄存器存放着诸如 <BS> 或其它特殊字符，这些字符就被解释成好像它们本来是从键
盘键入的。如果你不要这样解释 (你确实要在文本中插入 <BS>)，那么要命令 CTRL-R
CTRL-R {register}。

==============================================================================
*24.7*	缩写

缩写是取代一个长词的短词。例如，"ad" 指代 "advertisement"。Vim 让你键入缩写，
然后为你自动扩展。
   用以下命令告诉 Vim，每当你输入 "ad" 就把它扩展成 "advertisement": >

	:iabbrev ad advertisement

现在，当你键入 "ad"，完整的单词 'advertisement" 就被插入文本。键入一个不可能成
为单词一部分的字符，例如一个空格，就会触发缩写功能:

	输入的文本		看到的文本
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

当你仅仅键入 "ad" 时，扩展并没发生。它可以被你输入 "add" 这样的词而不被扩展。
Vim 只对那些完整的词检查缩写。


多 词 缩 写

为几个词定义一个缩写也是可能的。例如，用下面这个命令，把 "JB" 定义成 "Jack
Benny": >

	:iabbrev JB Jack Benny

作为程序员，我使用两个相当不寻常的缩写: >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

它们用于生成大段注释。注释以缩写 #b 开始，划出顶线。接着，我键入注释文字，最后
以缩写 #e 划出底线。
   注意缩写 #e 以一个空格开头。换言之，开头两个字符是空格和星号 (*)。通常 Vim
忽略不计位于缩写及其扩展之间的空格。为了避免空格被忽略，我把空格以七个字符表
示: <、S、p、a、c、e、>。

	备注:
	":iabbrev" 有点嫌长。":iab" 作用也一样。缩写命令被缩写了！


更 正 打 字 错 误

我们经常会犯同一个打字错误。例如，把 "the" 打成 "teh"。你可以利用缩写功能来更
正这样的错误: >

	:abbreviate teh the

你可以加上一系列这样的缩写。每次发现一个常见错误就加一个。


缩 写 列 表

":abbreviate" 命令列出所有缩写:

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

第一栏的 "i" 表明插入模式。这些缩写仅仅在插入模式下有作用。其它可能的字符:

	c	命令行模式      			:cabbrev
	!	插入模式和命令行模式            	:abbreviate

在命令行模式下使用缩写是不常见的。你主要会在插入模式下用 ":iabbrev" 命令。这样
就避免了不必要的扩展，例如，当你键入这样一条命令时，"ad" 就不会被扩展了: >

	:edit ad


删 除 缩 写

删除一个缩写，用 ":unabbreviate" 命令。假定你有以下缩写: >

	:abbreviate @f fresh

你可以用这个命令删除它: >

	:unabbreviate @f

当你键入这个命令的时候，你将注意到 @f 被扩展成 "fresh"。别担心，Vim 明白得很呢
(除非当你另有缩写 "fresh"，但那是很偶然的)。
   要删除全部缩写: >

	:abclear

":unabbreviate" 和 ":abclear" 另有变形，在插入模式下是 "iunabbreviate" 和
":iabclear"，在命令行模式下是 ":cunabbreviate" 和 "cabclear"。


缩 写 再 映 射

定义缩写时，有一点要注意的: 扩展产生的字符串不应当被映射成别的什么。例如: >

	:abbreviate @a adder
	:imap dd disk-door

现在，你键入 @a，你得到 "adisk-doorer"。那不是你要的结果。为了避免这种事发生，
用 ":noreabbrev" 命令。它的作用跟 ":abbreviate" 一样，但却避免了扩展产生的字符
串被用于映射: >

	:noreabbrev @a adder

现在好了，缩写扩展后的结果不可能被映射了。

==============================================================================
*24.8*	插入特殊字符

CTRL-V 命令用来插入下一个字面意义上的字符。换言之，无论该字符多特殊，其特殊含
义都被忽略不计。例如: >

	CTRL-V <Esc>

插入一个 <Esc> 字符。而你并未脱离插入模式。(不要在 CTRL-V 后面键入空格，那个空
格仅仅为了方便阅读)。

	备注:
	在 MS-Windows 环境下，CTRL-V 用来粘贴文本。所以用 CTRL-Q 代替 CTRL-V。
	另外，在 Unix 环境下，CTRL-Q 在某些终端上不起作用，因其另有特殊意义。

你也可以用命令 CTRL-V {digits} 来插入一个以若干个十进位数字 {digits} 表示的字
符。例如，字符编码 127 是字符 <Del> (但并不一定是 <Del> 键！)。要插入 <Del>，
键入: >

	CTRL-V 127

你可以用这样的方法输入数值不超过 255 的字符。当你键入一个不足两位的数字时，就
要添加一个非数字的字符来结束命令。为了回避这个非数字字符的要求，在它前面加一或
两个零以满足三位数的要求。
   以下命令都插入一个 <Tab> 字符，然后一个点字符:

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

输入一个 16 进制数字，在 CTRL-V 后面，用 "x" 开头: >

	CTRL-V x7f

这方法也可以用来输入数值不超过 255 (CTRL-V xff) 的字符。你可以用 "o" 开头输入
一个以 8 进制数表示的字符，以及另外两种方法，让你输入多至二进制 16 位和 32 位
的数字表示的字符 (例如，Unicode 字符): >

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	二合字母

有些字符在键盘上找不到。例如，表示版权的字符 (©) 要在 Vim 里键入这样的字符，你
得用二合字母，即以两个字符来表示一个。例如，要键入 ©， 你就得按三个键: >

	CTRL-K Co

你可以用以下命令来查找有哪些二合字母可供利用: >

	:digraphs

Vim 将把二合字母表显示在屏幕上。以下就是其中的三行:

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

这张表告诉你，比如，你键入 CTRL-K Pd 所得到的二合字母是字符 (£)。该字符编码为
163 (十进制)。
   Pd 是 Pound (英镑) 的简写。大多数二合字母让你一看就猜到两个字符生成什么字
符。如果你一个个读下来，便不难理解其中的逻辑。
   你可以交换两个字符的顺序，只要那样组合不代表另一个二合字母。因此 CTRL-K dP
也没问题。由于 "dP" 不是二合字母，Vim 会转而搜索表示成 "Pd" 的二合字母。

	备注:
	二合字母表取决于 Vim 假定你所使用的字符集。在 MS-DOS 系统上采用的二合
	字母集不同于 MS-Windows 系统上的。务必用 ":digraphs" 命令来查找当前可
	供利用的二合字符。

你可以定义你自己的二合字母。例如: >

	:digraph a" ä

以上命令定义了 CTRL-K a" 插入一个 ä 字符。你也可以用十进值数指定这个字符。下面
这个命令定义了同一个二合字母: >

	:digraph a" 228

更多关于二合字母信息参见: |digraphs|
   另一种插入特殊字符的方法是利用键盘映射。详情参见: |45.5|

==============================================================================
*24.10*	普通模式命令

插入模式提供的命令数量有限。在普通模式下，你可用的命令就多得多了。当你要用一个
普通模式命令时，你通常用 <Esc> 键来脱离插入模式，执行这个普通模式命令，然后再
用 "i" 或 "a" 命令重新进入插入模式。
   有一个快捷的方法。用 CTRL-O {command} 你可以在插入模式下执行任何普通模式命
令。例如，把光标后面直至行尾的文本删除: >

	CTRL-O D

用这个方法，你只能执行一个普通模式命令。但是，你可以指定一个寄存器或一个计数。
请看下面这个更复杂的命令: >

	CTRL-O "g3dw

这个命令把光标后面三个单词一起删除，存进了寄存器 g。

==============================================================================

下一章: |usr_25.txt|  编辑带格式的文本

版权: 参见 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
